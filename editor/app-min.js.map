{"version":3,"sources":["diff_match_patch_uncompressed.js","clunderscore.js","cldiffutils.js","cleditCore.js","cleditHighlighter.js","cleditKeystroke.js","cleditMarker.js","cleditSelectionMgr.js","cleditUndoMgr.js","cleditUtils.js","cleditWatcher.js","mdGrammar.js","prism-core.js","prism-markup.js","prism-clike.js","prism-javascript.js","prism-css.js","prism-actionscript.js","prism-apacheconf.js","prism-applescript.js","prism-aspnet.js","prism-autohotkey.js","prism-bash.js","prism-c.js","prism-coffeescript.js","prism-cpp.js","prism-csharp.js","prism-css-extras.js","prism-dart.js","prism-eiffel.js","prism-erlang.js","prism-fortran.js","prism-fsharp.js","prism-gherkin.js","prism-git.js","prism-go.js","prism-groovy.js","prism-haml.js","prism-handlebars.js","prism-haskell.js","prism-http.js","prism-ini.js","prism-jade.js","prism-java.js","prism-jsx.js","prism-julia.js","prism-latex.js","prism-less.js","prism-lolcode.js","prism-markdown.js","prism-matlab.js","prism-nasm.js","prism-nsis.js","prism-objectivec.js","prism-pascal.js","prism-perl.js","prism-php-extras.js","prism-php.js","prism-powershell.js","prism-python.js","prism-r.js","prism-rest.js","prism-rip.js","prism-ruby.js","prism-rust.js","prism-sas.js","prism-scala.js","prism-scheme.js","prism-scss.js","prism-smalltalk.js","prism-smarty.js","prism-sql.js","prism-stylus.js","prism-swift.js","prism-twig.js","prism-typescript.js","prism-wiki.js","prism-yaml.js","editor.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCjpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC5ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCvXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCxaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC1aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ECjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ECnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCCzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ICXA;AACA;AACA;AACA;AACA;AACA;AACA,CCNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ICdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ICjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ICpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WCnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ICPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCXA;AACA;AACA;AACA;AACA;AACA,GCLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGCzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCnBA;AACA;AACA;AACA;AACA;AACA,CCLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ICVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFCjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GCpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CCRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC9CA;AACA;AACA;AACA,CCHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CC5CA;AACA;AACA","file":"app-min.js","sourcesContent":["/**\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff_match_patch.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix]);\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = patch.diffs[y].slice();\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding]);\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push([DIFF_EQUAL, precontext]);\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push([diff_type, diff_text]);\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push([diff_type, diff_text]);\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line]);\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line]);\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line]);\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// Export these global variables so that they survive Google's JS compiler.\n// In a browser, 'this' will be 'window'.\n// Users of node.js should 'require' the uncompressed version since Google's\n// JS compiler may break the following exports for non-browser environments.\nthis['diff_match_patch'] = diff_match_patch;\nthis['DIFF_DELETE'] = DIFF_DELETE;\nthis['DIFF_INSERT'] = DIFF_INSERT;\nthis['DIFF_EQUAL'] = DIFF_EQUAL;\n","/* global HTMLCollection, NodeList */\n;(function () {\n  var arrayProperties = {}\n  var liveCollectionProperties = {}\n  var functionProperties = {}\n  var objectProperties = {}\n  var slice = Array.prototype.slice\n\n  arrayProperties.cl_each = function (cb) {\n    var i = 0\n    var length = this.length\n    for (; i < length; i++) {\n      cb(this[i], i, this)\n    }\n  }\n\n  arrayProperties.cl_map = function (cb) {\n    var i = 0\n    var length = this.length\n    var result = Array(length)\n    for (; i < length; i++) {\n      result[i] = cb(this[i], i, this)\n    }\n    return result\n  }\n\n  arrayProperties.cl_reduce = function (cb, memo) {\n    var i = 0\n    var length = this.length\n    for (; i < length; i++) {\n      memo = cb(memo, this[i], i, this)\n    }\n    return memo\n  }\n\n  arrayProperties.cl_some = function (cb) {\n    var i = 0\n    var length = this.length\n    for (; i < length; i++) {\n      if (cb(this[i], i, this)) {\n        return true\n      }\n    }\n  }\n\n  arrayProperties.cl_filter = function (cb) {\n    var i = 0\n    var length = this.length\n    var result = []\n    for (; i < length; i++) {\n      cb(this[i], i, this) && result.push(this[i])\n    }\n    return result\n  }\n\n  liveCollectionProperties.cl_each = function (cb) {\n    slice.call(this).cl_each(cb)\n  }\n\n  liveCollectionProperties.cl_map = function (cb) {\n    return slice.call(this).cl_map(cb)\n  }\n\n  liveCollectionProperties.cl_reduce = function (cb, memo) {\n    return slice.call(this).cl_reduce(cb, memo)\n  }\n\n  functionProperties.cl_bind = function (context) {\n    var self = this\n    var args = slice.call(arguments, 1)\n    context = context || null\n    return args.length\n      ? function () {\n        return arguments.length\n          ? self.apply(context, args.concat(slice.call(arguments)))\n          : self.apply(context, args)\n      }\n      : function () {\n        return arguments.length\n          ? self.apply(context, arguments)\n          : self.call(context)\n      }\n  }\n\n  objectProperties.cl_each = function (cb) {\n    var i = 0\n    var keys = Object.keys(this)\n    var length = keys.length\n    for (; i < length; i++) {\n      cb(this[keys[i]], keys[i], this)\n    }\n  }\n\n  objectProperties.cl_map = function (cb) {\n    var i = 0\n    var keys = Object.keys(this)\n    var length = keys.length\n    var result = Array(length)\n    for (; i < length; i++) {\n      result[i] = cb(this[keys[i]], keys[i], this)\n    }\n    return result\n  }\n\n  objectProperties.cl_reduce = function (cb, memo) {\n    var i = 0\n    var keys = Object.keys(this)\n    var length = keys.length\n    for (; i < length; i++) {\n      memo = cb(memo, this[keys[i]], keys[i], this)\n    }\n    return memo\n  }\n\n  objectProperties.cl_extend = function (obj) {\n    if (obj) {\n      var i = 0\n      var keys = Object.keys(obj)\n      var length = keys.length\n      for (; i < length; i++) {\n        this[keys[i]] = obj[keys[i]]\n      }\n    }\n    return this\n  }\n\n  function build (properties) {\n    return objectProperties.cl_reduce.call(properties, function (memo, value, key) {\n      memo[key] = {\n        value: value\n      }\n      return memo\n    }, {})\n  }\n\n  arrayProperties = build(arrayProperties)\n  liveCollectionProperties = build(liveCollectionProperties)\n  functionProperties = build(functionProperties)\n  objectProperties = build(objectProperties)\n\n  /* eslint-disable no-extend-native */\n  Object.defineProperties(Array.prototype, arrayProperties)\n  Object.defineProperties(Int8Array.prototype, arrayProperties)\n  Object.defineProperties(Uint8Array.prototype, arrayProperties)\n  Object.defineProperties(Uint8ClampedArray.prototype, arrayProperties)\n  Object.defineProperties(Int16Array.prototype, arrayProperties)\n  Object.defineProperties(Uint16Array.prototype, arrayProperties)\n  Object.defineProperties(Int32Array.prototype, arrayProperties)\n  Object.defineProperties(Uint32Array.prototype, arrayProperties)\n  Object.defineProperties(Float32Array.prototype, arrayProperties)\n  Object.defineProperties(Float64Array.prototype, arrayProperties)\n  Object.defineProperties(Function.prototype, functionProperties)\n  Object.defineProperties(Object.prototype, objectProperties)\n  if (typeof window !== 'undefined') {\n    Object.defineProperties(HTMLCollection.prototype, liveCollectionProperties)\n    Object.defineProperties(NodeList.prototype, liveCollectionProperties)\n  }\n})()\n",";(function (root, factory) {\n  if (typeof exports === 'object') {\n    require('clunderscore')\n    module.exports = factory(require('googlediff'))\n  } else {\n    root.clDiffUtils = factory(root.diff_match_patch)\n  }\n})(this, function (diff_match_patch) {\n  var clDiffUtils = {}\n  var marker = '\\uF111\\uF222\\uF333\\uF444'\n  var DIFF_DELETE = -1\n  var DIFF_INSERT = 1\n  var DIFF_EQUAL = 0\n  var diffMatchPatch = new diff_match_patch() // eslint-disable-line new-cap\n  var diffMatchPatchStrict = new diff_match_patch() // eslint-disable-line new-cap\n  diffMatchPatchStrict.Match_Threshold = 0\n  diffMatchPatchStrict.Patch_DeleteThreshold = 0\n  var diffMatchPatchPermissive = new diff_match_patch() // eslint-disable-line new-cap\n  diffMatchPatchPermissive.Match_Distance = 999999999\n\n  function offsetToPatch (text, offset) {\n    var patch = diffMatchPatchPermissive.patch_make(text, [\n      [0, text.slice(0, offset)],\n      [1, marker],\n      [0, text.slice(offset)]\n    ])[0]\n    var diffs = patch.diffs.cl_map(function (diff) {\n      if (!diff[0]) {\n        return diff[1]\n      } else if (diff[1] === marker) {\n        return ''\n      }\n    })\n    return {\n      diffs: diffs,\n      length: patch.length1,\n      start: patch.start1\n    }\n  }\n\n  function patchToOffset (text, patch) {\n    var markersLength = 0\n    var diffs = patch.diffs.cl_map(function (diff) {\n      if (!diff) {\n        markersLength += marker.length\n        return [1, marker]\n      } else {\n        return [0, diff]\n      }\n    })\n    return diffMatchPatchPermissive.patch_apply([{\n      diffs: diffs,\n      length1: patch.length,\n      length2: patch.length + markersLength,\n      start1: patch.start,\n      start2: patch.start\n    }], text)[0].indexOf(marker)\n  }\n\n  function flattenObject (obj) {\n    return obj.cl_reduce(function (result, value, key) {\n      result[key] = value[1]\n      return result\n    }, {})\n  }\n\n  function flattenContent (content, doChars) {\n    return ({}).cl_extend(content).cl_extend({\n      text: content.text.cl_map(function (item) {\n        return item[1]\n      }).join(''),\n      chars: doChars && content.text\n          .cl_reduce(function (chars, item) {\n            return chars.concat(item[1].split('').cl_map(function (c) {\n              return [item[0], c]\n            }))\n          }, []),\n      properties: flattenObject(content.properties),\n      discussions: flattenObject(content.discussions),\n      comments: flattenObject(content.comments),\n      conflicts: flattenObject(content.conflicts)\n    })\n  }\n\n  function applyFlattenedObjectPatches (obj, patches) {\n    patches && patches.cl_each(function (patch) {\n      if (patch.a) {\n        obj[patch.k] = patch.a\n      } else if (patch.d) {\n        delete obj[patch.k]\n      }\n    })\n  }\n\n  function applyFlattenedObjectPatchesReverse (obj, patches) {\n    patches && patches.cl_each(function (patch) {\n      if (patch.d) {\n        obj[patch.k] = patch.d\n      } else if (patch.a) {\n        delete obj[patch.k]\n      }\n    })\n  }\n\n  function applyFlattenedTextPatches (text, patches) {\n    return (patches || []).cl_reduce(function (text, patch) {\n      if (patch.a) {\n        return text.slice(0, patch.o).concat(patch.a).concat(text.slice(patch.o))\n      } else if (patch.d) {\n        return text.slice(0, patch.o).concat(text.slice(patch.o + patch.d.length))\n      } else {\n        return text\n      }\n    }, text)\n  }\n\n  function applyFlattenedTextPatchesReverse (text, patches) {\n    return (patches || []).cl_reduce(function (text, patch) {\n      if (patch.d) {\n        return text.slice(0, patch.o).concat(patch.d).concat(text.slice(patch.o))\n      } else if (patch.a) {\n        return text.slice(0, patch.o).concat(text.slice(patch.o + patch.a.length))\n      } else {\n        return text\n      }\n    }, text)\n  }\n\n  function applyCharPatches (chars, patches, userId) {\n    return (patches || []).cl_reduce(function (chars, patch) {\n      if (patch.a) {\n        return chars.slice(0, patch.o).concat(patch.a.split('').cl_map(function (c) {\n          return [userId, c]\n        })).concat(chars.slice(patch.o))\n      } else if (patch.d) {\n        return chars.slice(0, patch.o).concat(chars.slice(patch.o + patch.d.length))\n      } else {\n        return chars\n      }\n    }, chars)\n  }\n\n  function applyFlattenedContentChanges (content, contentChanges, doChars) {\n    var userId\n    var properties = ({}).cl_extend(content.properties)\n    var discussions = ({}).cl_extend(content.discussions)\n    var comments = ({}).cl_extend(content.comments)\n    var conflicts = ({}).cl_extend(content.conflicts)\n    var text = content.text\n    var chars = doChars && content.chars.slice()\n    contentChanges = contentChanges || []\n    contentChanges.cl_each(function (contentChange) {\n      applyFlattenedObjectPatches(properties, contentChange.properties)\n      applyFlattenedObjectPatches(discussions, contentChange.discussions)\n      applyFlattenedObjectPatches(comments, contentChange.comments)\n      applyFlattenedObjectPatches(conflicts, contentChange.conflicts)\n      text = applyFlattenedTextPatches(text, contentChange.text)\n      if (doChars) {\n        userId = contentChange.userId || userId\n        chars = applyCharPatches(chars, contentChange.text, userId)\n      }\n    })\n    return {\n      chars: chars,\n      text: text,\n      properties: properties,\n      discussions: discussions,\n      comments: comments,\n      conflicts: conflicts,\n      rev: content.rev + contentChanges.length\n    }\n  }\n\n  function getTextPatches (oldText, newText) {\n    var diffs = diffMatchPatch.diff_main(oldText, newText)\n    diffMatchPatch.diff_cleanupEfficiency(diffs)\n    var patches = []\n    var startOffset = 0\n    diffs.cl_each(function (change) {\n      var changeType = change[0]\n      var changeText = change[1]\n      switch (changeType) {\n        case DIFF_EQUAL:\n          startOffset += changeText.length\n          break\n        case DIFF_DELETE:\n          changeText && patches.push({\n            o: startOffset,\n            d: changeText\n          })\n          break\n        case DIFF_INSERT:\n          changeText && patches.push({\n            o: startOffset,\n            a: changeText\n          })\n          startOffset += changeText.length\n          break\n      }\n    })\n    return patches.length ? patches : undefined\n  }\n\n  function getObjectPatches (oldObject, newObjects) {\n    var valueHash = Object.create(null)\n    var valueArray = []\n    oldObject = hashObject(oldObject, valueHash, valueArray)\n    newObjects = hashObject(newObjects, valueHash, valueArray)\n    var diffs = diffMatchPatch.diff_main(oldObject, newObjects)\n    var patches = []\n    diffs.cl_each(function (change) {\n      var changeType = change[0]\n      var changeHash = change[1]\n      if (changeType === DIFF_EQUAL) {\n        return\n      }\n      changeHash.split('').cl_each(function (objHash) {\n        var obj = valueArray[objHash.charCodeAt(0)]\n        var patch = {\n          k: obj[0]\n        }\n        patch[changeType === DIFF_DELETE ? 'd' : 'a'] = obj[1]\n        patches.push(patch)\n      })\n    })\n    return patches.length ? patches : undefined\n  }\n\n  function serializeObject (obj) {\n    return JSON.stringify(obj, function (key, value) {\n      return Object.prototype.toString.call(value) === '[object Object]'\n        ? Object.keys(value).sort().cl_reduce(function (sorted, key) {\n          sorted[key] = value[key]\n          return sorted\n        }, {})\n        : value\n    })\n  }\n\n  function hashArray (arr, valueHash, valueArray) {\n    var hash = []\n    arr.cl_each(function (obj) {\n      var serializedObj = serializeObject(obj)\n      var objHash = valueHash[serializedObj]\n      if (objHash === undefined) {\n        objHash = valueArray.length\n        valueArray.push(obj)\n        valueHash[serializedObj] = objHash\n      }\n      hash.push(objHash)\n    })\n    return String.fromCharCode.apply(null, hash)\n  }\n\n  function hashObject (obj, valueHash, valueArray) {\n    return hashArray(Object.keys(obj || {}).sort().cl_map(function (key) {\n      return [key, obj[key]]\n    }), valueHash, valueArray)\n  }\n\n  function unhashArray (hash, valueArray) {\n    return hash.split('').cl_map(function (objHash) {\n      return valueArray[objHash.charCodeAt(0)]\n    })\n  }\n\n  function mergeText (oldText, newText, serverText) {\n    var valueHash = Object.create(null)\n    var valueArray = []\n    var oldHash = hashArray(oldText.split('\\n'), valueHash, valueArray)\n    var newHash = hashArray(serverText.split('\\n'), valueHash, valueArray)\n    var serverHash = hashArray(newText.split('\\n'), valueHash, valueArray)\n    var diffs = diffMatchPatchStrict.diff_main(oldHash, newHash)\n    var patches = diffMatchPatchStrict.patch_make(oldHash, diffs)\n    var patchResult = diffMatchPatchStrict.patch_apply(patches, serverHash)\n    if (!patchResult[1]\n        .cl_some(function (changeApplied) {\n          return !changeApplied\n        })) {\n      return [unhashArray(patchResult[0], valueArray).join('\\n'), []]\n    }\n    var conflicts = []\n    var conflict = {}\n    var lastType\n    var resultHash = ''\n    diffs = diffMatchPatchStrict.diff_main(patchResult[0], newHash)\n    diffs.cl_each(function (diff) {\n      var diffType = diff[0]\n      var diffText = diff[1]\n      resultHash += diffText\n      if (diffType !== lastType) {\n        if (conflict.offset3) {\n          conflicts.push(conflict)\n          conflict = {}\n        }\n        if (conflict.offset2) {\n          if (diffType === DIFF_EQUAL) {\n            conflict = {}\n          } else {\n            conflict.offset3 = resultHash.length\n          }\n        } else if (diffType !== DIFF_EQUAL) {\n          conflict.offset1 = resultHash.length - diffText.length\n          conflict.offset2 = resultHash.length\n        }\n      }\n      lastType = diffType\n    })\n    conflict.offset3 && conflicts.push(conflict)\n    var resultLines = unhashArray(resultHash, valueArray)\n    var resultStr = resultLines.join('\\n')\n    var lastOffset = 0\n    var resultLineOffsets = resultLines.cl_map(function (resultLine) {\n      var result = lastOffset\n      lastOffset += resultLine.length + 1\n      return result\n    })\n    return [resultStr, conflicts.cl_map(function (conflict) {\n      return {\n        patches: [\n          offsetToPatch(resultStr, resultLineOffsets[conflict.offset1]),\n          offsetToPatch(resultStr, resultLineOffsets[conflict.offset2]),\n          offsetToPatch(resultStr, resultLineOffsets[conflict.offset3])\n        ]\n      }\n    })]\n  }\n\n  function quickPatch (oldStr, newStr, destStr, strict) {\n    var dmp = strict ? diffMatchPatchStrict : diffMatchPatch\n    var diffs = dmp.diff_main(oldStr, newStr)\n    var patches = dmp.patch_make(oldStr, diffs)\n    var patchResult = dmp.patch_apply(patches, destStr)\n    return patchResult[0]\n  }\n\n  function mergeObjects (oldObject, newObject, serverObject) {\n    var mergedObject = ({}).cl_extend(newObject).cl_extend(serverObject)\n    mergedObject.cl_each(function (value, key) {\n      if (!oldObject[key]) {\n        return // There might be conflict, keep the server value\n      }\n      var newValue = newObject[key] && serializeObject(newObject[key])\n      var serverValue = serverObject[key] && serializeObject(serverObject[key])\n      if (newValue === serverValue) {\n        return // no conflict\n      }\n      var oldValue = serializeObject(oldObject[key])\n      if (oldValue !== newValue && !serverValue) {\n        return // Removed on server but changed on client\n      }\n      if (oldValue !== serverValue && !newValue) {\n        return // Removed on client but changed on server\n      }\n      if (oldValue !== newValue && oldValue === serverValue) {\n        // Take the client value\n        if (!newValue) {\n          delete mergedObject[key]\n        } else {\n          mergedObject[key] = newObject[key]\n        }\n      } else if (oldValue !== serverValue && oldValue === newValue) {\n        // Take the server value\n        if (!serverValue) {\n          delete mergedObject[key]\n        }\n      }\n    // Take the server value otherwise\n    })\n    return mergedObject\n  }\n\n  function mergeContent (oldContent, newContent, serverContent) {\n    var oldText = oldContent.text\n    var serverText = serverContent.text\n    var localText = newContent.text\n    var isServerTextChanges = oldText !== serverText\n    var isLocalTextChanges = oldText !== localText\n    var isTextSynchronized = serverText === localText\n    var conflicts = []\n    if (!isTextSynchronized && isServerTextChanges && isLocalTextChanges) {\n      var textWithConflicts = mergeText(oldText, serverText, localText)\n      newContent.text = textWithConflicts[0]\n      conflicts = textWithConflicts[1]\n    } else if (!isTextSynchronized && isServerTextChanges) {\n      newContent.text = serverText\n    }\n\n    newContent.properties = mergeObjects(oldContent.properties, newContent.properties, serverContent.properties)\n    newContent.discussions = mergeObjects(oldContent.discussions, newContent.discussions, serverContent.discussions)\n    newContent.comments = mergeObjects(oldContent.comments, newContent.comments, serverContent.comments)\n    newContent.conflicts = mergeObjects(oldContent.conflicts, newContent.conflicts, serverContent.conflicts)\n    return conflicts\n  }\n\n  clDiffUtils.offsetToPatch = offsetToPatch\n  clDiffUtils.patchToOffset = patchToOffset\n  clDiffUtils.serializeObject = serializeObject\n  clDiffUtils.flattenContent = flattenContent\n  clDiffUtils.applyFlattenedObjectPatches = applyFlattenedObjectPatches\n  clDiffUtils.applyFlattenedObjectPatchesReverse = applyFlattenedObjectPatchesReverse\n  clDiffUtils.applyFlattenedTextPatches = applyFlattenedTextPatches\n  clDiffUtils.applyFlattenedTextPatchesReverse = applyFlattenedTextPatchesReverse\n  clDiffUtils.applyCharPatches = applyCharPatches\n  clDiffUtils.applyFlattenedContentChanges = applyFlattenedContentChanges\n  clDiffUtils.getTextPatches = getTextPatches\n  clDiffUtils.getObjectPatches = getObjectPatches\n  clDiffUtils.quickPatch = quickPatch\n  clDiffUtils.mergeObjects = mergeObjects\n  clDiffUtils.mergeContent = mergeContent\n  return clDiffUtils\n})\n","/* jshint -W084, -W099 */\n\n(function(diff_match_patch) {\n\tfunction cledit(contentElt, scrollElt, windowParam) {\n\t\tscrollElt = scrollElt || contentElt\n\t\tvar editor = {\n\t\t\t$contentElt: contentElt,\n\t\t\t$scrollElt: scrollElt,\n\t\t\t$window: windowParam || window,\n\t\t\t$keystrokes: [],\n\t\t\t$markers: {}\n\t\t}\n\t\teditor.$document = editor.$window.document\n\t\tcledit.Utils.createEventHooks(editor)\n\t\tvar debounce = cledit.Utils.debounce\n\n\t\teditor.toggleEditable = function(isEditable) {\n\t\t\tif (isEditable === undefined) {\n\t\t\t\tisEditable = !contentElt.contentEditable\n\t\t\t}\n\t\t\tcontentElt.contentEditable = isEditable\n\t\t}\n\t\teditor.toggleEditable(true)\n\n\t\tfunction getTextContent() {\n\t\t\tvar textContent = contentElt.textContent.replace(/\\r\\n?/g, '\\n') // Mac/DOS to Unix\n\t\t\tif (textContent.slice(-1) !== '\\n') {\n\t\t\t\ttextContent += '\\n'\n\t\t\t}\n\t\t\treturn textContent\n\t\t}\n\n\t\tvar lastTextContent = getTextContent()\n\t\tvar highlighter = new cledit.Highlighter(editor)\n\n\t\tvar sectionList\n\n\t\tfunction parseSections(content, isInit) {\n\t\t\tsectionList = highlighter.parseSections(content, isInit)\n\t\t\teditor.$allElements = Array.prototype.slice.call(contentElt.querySelectorAll('.cledit-section *'))\n\t\t\teditor.$trigger('contentChanged', content, sectionList)\n\t\t}\n\n\t\t// Used to detect editor changes\n\t\tvar watcher = new cledit.Watcher(editor, checkContentChange)\n\t\twatcher.startWatching()\n\n\t\tvar diffMatchPatch = new diff_match_patch()\n\t\tvar selectionMgr = new cledit.SelectionMgr(editor)\n\n\t\tfunction adjustCursorPosition(force) {\n\t\t\tselectionMgr.saveSelectionState(true, true, force)\n\t\t}\n\n\t\tfunction replaceContent(selectionStart, selectionEnd, replacement) {\n\t\t\tvar min = Math.min(selectionStart, selectionEnd)\n\t\t\tvar max = Math.max(selectionStart, selectionEnd)\n\t\t\tvar range = selectionMgr.createRange(min, max)\n\t\t\tvar rangeText = '' + range\n\t\t\t// Range can contain a br element, which is not taken into account in rangeText\n\t\t\tif (rangeText.length === max - min && rangeText === replacement) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trange.deleteContents()\n\t\t\trange.insertNode(editor.$document.createTextNode(replacement))\n\t\t\treturn range\n\t\t}\n\n\t\tvar ignorePatches = false,\n\t\t\tnoContentFix = false\n\n\t\tfunction setContent(value, noUndo, maxStartOffset) {\n\t\t\tvar textContent = getTextContent()\n\t\t\tmaxStartOffset = maxStartOffset !== undefined && maxStartOffset < textContent.length ? maxStartOffset : textContent.length - 1\n\t\t\tvar startOffset = Math.min(\n\t\t\t\tdiffMatchPatch.diff_commonPrefix(textContent, value),\n\t\t\t\tmaxStartOffset\n\t\t\t)\n\t\t\tvar endOffset = Math.min(\n\t\t\t\tdiffMatchPatch.diff_commonSuffix(textContent, value),\n\t\t\t\ttextContent.length - startOffset,\n\t\t\t\tvalue.length - startOffset\n\t\t\t)\n\t\t\tvar replacement = value.substring(startOffset, value.length - endOffset)\n\t\t\tvar range = replaceContent(startOffset, textContent.length - endOffset, replacement)\n\t\t\tif (range) {\n\t\t\t\tignorePatches = noUndo\n\t\t\t\tnoContentFix = true\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstart: startOffset,\n\t\t\t\tend: value.length - endOffset,\n\t\t\t\trange: range\n\t\t\t}\n\t\t}\n\n\t\tfunction replace(selectionStart, selectionEnd, replacement) {\n\t\t\tundoMgr.setDefaultMode('single')\n\t\t\treplaceContent(selectionStart, selectionEnd, replacement)\n\t\t\tvar endOffset = selectionStart + replacement.length\n\t\t\tselectionMgr.setSelectionStartEnd(endOffset, endOffset)\n\t\t\tselectionMgr.updateCursorCoordinates(true)\n\t\t}\n\n\t\tfunction replaceAll(search, replacement) {\n\t\t\tundoMgr.setDefaultMode('single')\n\t\t\tvar textContent = getTextContent()\n\t\t\tvar value = textContent.replace(search, replacement)\n\t\t\tif (value !== textContent) {\n\t\t\t\tvar offset = editor.setContent(value)\n\t\t\t\tselectionMgr.setSelectionStartEnd(offset.end, offset.end)\n\t\t\t\tselectionMgr.updateCursorCoordinates(true)\n\t\t\t}\n\t\t}\n\n\t\tfunction focus() {\n\t\t\tselectionMgr.restoreSelection()\n\t\t}\n\n\t\tvar undoMgr = new cledit.UndoMgr(editor)\n\n\t\tfunction addMarker(marker) {\n\t\t\teditor.$markers[marker.id] = marker\n\t\t}\n\n\t\tfunction removeMarker(marker) {\n\t\t\tdelete editor.$markers[marker.id]\n\t\t}\n\n\t\tvar triggerSpellCheck = debounce(function() {\n\t\t\tvar selection = editor.$window.getSelection()\n\t\t\tif (!selectionMgr.hasFocus || highlighter.isComposing || selectionMgr.selectionStart !== selectionMgr.selectionEnd || !selection.modify) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Hack for Chrome to trigger the spell checker\n\t\t\tif (selectionMgr.selectionStart) {\n\t\t\t\tselection.modify('move', 'backward', 'character')\n\t\t\t\tselection.modify('move', 'forward', 'character')\n\t\t\t} else {\n\t\t\t\tselection.modify('move', 'forward', 'character')\n\t\t\t\tselection.modify('move', 'backward', 'character')\n\t\t\t}\n\t\t}, 10)\n\n\t\tfunction checkContentChange(mutations) {\n\t\t\twatcher.noWatch(function() {\n\t\t\t\tvar removedSections = []\n\t\t\t\tvar modifiedSections = []\n\n\t\t\t\tfunction markModifiedSection(node) {\n\t\t\t\t\twhile (node && node !== contentElt) {\n\t\t\t\t\t\tif (node.section) {\n\t\t\t\t\t\t\tvar array = node.parentNode ? modifiedSections : removedSections\n\t\t\t\t\t\t\treturn array.indexOf(node.section) === -1 && array.push(node.section)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode = node.parentNode\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmutations.cl_each(function(mutation) {\n\t\t\t\t\tmarkModifiedSection(mutation.target)\n\t\t\t\t\tmutation.addedNodes.cl_each(markModifiedSection)\n\t\t\t\t\tmutation.removedNodes.cl_each(markModifiedSection)\n\t\t\t\t})\n\t\t\t\thighlighter.fixContent(modifiedSections, removedSections, noContentFix)\n\t\t\t\tnoContentFix = false\n\t\t\t})\n\t\t\tvar newTextContent = getTextContent()\n\t\t\tvar diffs = diffMatchPatch.diff_main(lastTextContent, newTextContent)\n\t\t\tif (!ignorePatches) {\n\t\t\t\tvar patches = diffMatchPatch.patch_make(lastTextContent, diffs)\n\t\t\t\tundoMgr.addPatches(patches)\n\t\t\t\tundoMgr.setDefaultMode('typing')\n\t\t\t}\n\n\t\t\teditor.$markers.cl_each(function(marker) {\n\t\t\t\tmarker.adjustOffset(diffs)\n\t\t\t})\n\n\t\t\tlastTextContent = newTextContent\n\t\t\tselectionMgr.saveSelectionState()\n\t\t\tparseSections(lastTextContent)\n\t\t\tignorePatches || undoMgr.saveState()\n\t\t\tignorePatches = false\n\t\t\ttriggerSpellCheck()\n\t\t}\n\n\t\t// See https://gist.github.com/shimondoodkin/1081133\n\t\t// TODO\n\t\t/*\n\t\t if(/AppleWebKit\\/([\\d.]+)/.exec(navigator.userAgent)) {\n\t\t var $editableFix = $('<input style=\"width:1px;height:1px;border:none;margin:0;padding:0;\" tabIndex=\"-1\">').appendTo('html')\n\t\t $contentElt.blur(function() {\n\t\t $editableFix[0].setSelectionRange(0, 0)\n\t\t $editableFix.blur()\n\t\t })\n\t\t }\n\t\t */\n\n\t\tfunction setSelection(start, end) {\n\t\t\tend = end === undefined ? start : end\n\t\t\tselectionMgr.setSelectionStartEnd(start, end)\n\t\t\tselectionMgr.updateCursorCoordinates()\n\t\t}\n\n\t\tfunction keydownHandler(handler) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (\n\t\t\t\t\tevt.which !== 17 && // Ctrl\n\t\t\t\t\tevt.which !== 91 && // Cmd\n\t\t\t\t\tevt.which !== 18 && // Alt\n\t\t\t\t\tevt.which !== 16 // Shift\n\t\t\t\t) {\n\t\t\t\t\thandler(evt)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\t\t\teditor.$window.removeEventListener('keydown', windowKeydownListener)\n\t\t\teditor.$window.removeEventListener('mouseup', windowMouseupListener)\n\t\t}\n\n\t\t// In case of Ctrl/Cmd+A outside the editor element\n\t\tfunction windowKeydownListener(evt) {\n\t\t\tif (!editor.$window.document.contains(contentElt)) {\n\t\t\t\treturn removeEventListeners()\n\t\t\t}\n\t\t\tkeydownHandler(function() {\n\t\t\t\tadjustCursorPosition()\n\t\t\t})(evt)\n\t\t}\n\t\teditor.$window.addEventListener('keydown', windowKeydownListener, false)\n\n\t\t// Mouseup can happen outside the editor element\n\t\tfunction windowMouseupListener() {\n\t\t\tif (!editor.$window.document.contains(contentElt)) {\n\t\t\t\treturn removeEventListeners()\n\t\t\t}\n\t\t\tselectionMgr.saveSelectionState(true, false)\n\t\t}\n\t\teditor.$window.addEventListener('mouseup', windowMouseupListener)\n\t\t// This can also provoke selection changes and does not fire mouseup event on Chrome/OSX\n\t\tcontentElt.addEventListener('contextmenu', selectionMgr.saveSelectionState.cl_bind(selectionMgr, true, false))\n\n\t\tcontentElt.addEventListener('keydown', keydownHandler(function(evt) {\n\t\t\tselectionMgr.saveSelectionState()\n\t\t\tadjustCursorPosition()\n\n\t\t\t// Perform keystroke\n\t\t\tvar textContent = editor.getContent()\n\t\t\tvar min = Math.min(selectionMgr.selectionStart, selectionMgr.selectionEnd)\n\t\t\tvar max = Math.max(selectionMgr.selectionStart, selectionMgr.selectionEnd)\n\t\t\tvar state = {\n\t\t\t\tbefore: textContent.slice(0, min),\n\t\t\t\tafter: textContent.slice(max),\n\t\t\t\tselection: textContent.slice(min, max),\n\t\t\t\tisBackwardSelection: selectionMgr.selectionStart > selectionMgr.selectionEnd\n\t\t\t}\n\t\t\teditor.$keystrokes.cl_some(function(keystroke) {\n\t\t\t\tif (keystroke.handler(evt, state, editor)) {\n\t\t\t\t\teditor.setContent(state.before + state.selection + state.after, false, min)\n\t\t\t\t\tmin = state.before.length\n\t\t\t\t\tmax = min + state.selection.length\n\t\t\t\t\tselectionMgr.setSelectionStartEnd(\n\t\t\t\t\t\tstate.isBackwardSelection ? max : min,\n\t\t\t\t\t\tstate.isBackwardSelection ? min : max\n\t\t\t\t\t)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t})\n\t\t}), false)\n\n\t\tcontentElt.addEventListener('compositionstart', function() {\n\t\t\thighlighter.isComposing++\n\t\t}, false)\n\n\t\tcontentElt.addEventListener('compositionend', function() {\n\t\t\tsetTimeout(function() {\n\t\t\t\thighlighter.isComposing && highlighter.isComposing--\n\t\t\t}, 0)\n\t\t}, false)\n\n\t\tcontentElt.addEventListener('paste', function(evt) {\n\t\t\tundoMgr.setCurrentMode('single')\n\t\t\tevt.preventDefault()\n\t\t\tvar data, clipboardData = evt.clipboardData\n\t\t\tif (clipboardData) {\n\t\t\t\tdata = clipboardData.getData('text/plain')\n\t\t\t} else {\n\t\t\t\tclipboardData = editor.$window.clipboardData\n\t\t\t\tdata = clipboardData && clipboardData.getData('Text')\n\t\t\t}\n\t\t\tif (!data) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treplace(selectionMgr.selectionStart, selectionMgr.selectionEnd, data)\n\t\t\tadjustCursorPosition()\n\t\t}, false)\n\n\t\tcontentElt.addEventListener('cut', function() {\n\t\t\tundoMgr.setCurrentMode('single')\n\t\t\tadjustCursorPosition()\n\t\t}, false)\n\n\t\tcontentElt.addEventListener('focus', function() {\n\t\t\tselectionMgr.hasFocus = true\n\t\t\teditor.$trigger('focus')\n\t\t}, false)\n\n\t\tcontentElt.addEventListener('blur', function() {\n\t\t\tselectionMgr.hasFocus = false\n\t\t\teditor.$trigger('blur')\n\t\t}, false)\n\n\t\tfunction addKeystroke(keystrokes) {\n\t\t\tif (!Array.isArray(keystrokes)) {\n\t\t\t\tkeystrokes = [keystrokes]\n\t\t\t}\n\t\t\teditor.$keystrokes = editor.$keystrokes.concat(keystrokes).sort(function(keystroke1, keystroke2) {\n\t\t\t\treturn keystroke1.priority - keystroke2.priority\n\t\t\t})\n\t\t}\n\t\taddKeystroke(cledit.defaultKeystrokes)\n\n\t\teditor.selectionMgr = selectionMgr\n\t\teditor.undoMgr = undoMgr\n\t\teditor.highlighter = highlighter\n\t\teditor.watcher = watcher\n\t\teditor.adjustCursorPosition = adjustCursorPosition\n\t\teditor.setContent = setContent\n\t\teditor.replace = replace\n\t\teditor.replaceAll = replaceAll\n\t\teditor.getContent = getTextContent\n\t\teditor.focus = focus\n\t\teditor.setSelection = setSelection\n\t\teditor.addKeystroke = addKeystroke\n\t\teditor.addMarker = addMarker\n\t\teditor.removeMarker = removeMarker\n\n\t\teditor.init = function(options) {\n\t\t\toptions = ({\n\t\t\t\tcursorFocusRatio: 0.5,\n\t\t\t\thighlighter: function(text) {\n\t\t\t\t\treturn text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ')\n\t\t\t\t},\n\t\t\t\tsectionDelimiter: ''\n\t\t\t}).cl_extend(options || {})\n\t\t\teditor.options = options\n\n\t\t\tif (options.content !== undefined) {\n\t\t\t\tlastTextContent = options.content.toString()\n\t\t\t\tif (lastTextContent.slice(-1) !== '\\n') {\n\t\t\t\t\tlastTextContent += '\\n'\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparseSections(lastTextContent, true)\n\t\t\tif (options.selectionStart !== undefined && options.selectionEnd !== undefined) {\n\t\t\t\teditor.setSelection(options.selectionStart, options.selectionEnd)\n\t\t\t} else {\n\t\t\t\tselectionMgr.saveSelectionState()\n\t\t\t}\n\t\t\tundoMgr.init()\n\n\t\t\tif (options.scrollTop !== undefined) {\n\t\t\t\tscrollElt.scrollTop = options.scrollTop\n\t\t\t}\n\t\t}\n\n\t\treturn editor\n\t}\n\n\twindow.cledit = cledit\n})(window.diff_match_patch)\n","(function(cledit) {\n\tvar styleElts = []\n\n\tfunction createStyleSheet(document) {\n\t\tvar styleElt = document.createElement('style')\n\t\tstyleElt.type = 'text/css'\n\t\tstyleElt.innerHTML = '.cledit-section * { display: inline; }'\n\t\tdocument.head.appendChild(styleElt)\n\t\tstyleElts.push(styleElt)\n\t}\n\n\tfunction Highlighter(editor) {\n\t\tvar self = this\n\t\tcledit.Utils.createEventHooks(this)\n\n\t\tstyleElts.cl_some(function(styleElt) {\n\t\t\treturn editor.$document.head.contains(styleElt)\n\t\t}) || createStyleSheet(editor.$document)\n\n\t\tvar contentElt = editor.$contentElt\n\t\tthis.isComposing = 0\n\n\t\tvar sectionList = []\n\t\tvar insertBeforeSection\n\t\tvar useBr = cledit.Utils.isWebkit\n\t\tvar trailingNodeTag = 'div'\n\t\tvar hiddenLfInnerHtml = '<br><span class=\"hd-lf\" style=\"display: none\">\\n</span>'\n\n\t\tvar lfHtml = '<span class=\"lf\">' + (useBr ? hiddenLfInnerHtml : '\\n') + '</span>'\n\n\t\tthis.fixContent = function(modifiedSections, removedSections, noContentFix) {\n\t\t\tmodifiedSections.cl_each(function(section) {\n\t\t\t\tsection.forceHighlighting = true\n\t\t\t\tif (!noContentFix) {\n\t\t\t\t\tif (useBr) {\n\t\t\t\t\t\tsection.elt.getElementsByClassName('hd-lf').cl_each(function(lfElt) {\n\t\t\t\t\t\t\tlfElt.parentNode.removeChild(lfElt)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tsection.elt.getElementsByTagName('br').cl_each(function(brElt) {\n\t\t\t\t\t\t\tbrElt.parentNode.replaceChild(editor.$document.createTextNode('\\n'), brElt)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tif (section.elt.textContent.slice(-1) !== '\\n') {\n\t\t\t\t\t\tsection.elt.appendChild(editor.$document.createTextNode('\\n'))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis.addTrailingNode = function() {\n\t\t\tthis.trailingNode = editor.$document.createElement(trailingNodeTag)\n\t\t\tcontentElt.appendChild(this.trailingNode)\n\t\t}\n\n\t\tfunction Section(text) {\n\t\t\tthis.text = text\n\t\t}\n\n\t\tSection.prototype.setElement = function(elt) {\n\t\t\tthis.elt = elt\n\t\t\telt.section = this\n\t\t}\n\n\t\tthis.parseSections = function(content, isInit) {\n\t\t\tif (this.isComposing) {\n\t\t\t\treturn sectionList\n\t\t\t}\n\n\t\t\tvar newSectionList = editor.options.sectionParser ? editor.options.sectionParser(content) : [content]\n\t\t\tnewSectionList = newSectionList.cl_map(function(sectionText) {\n\t\t\t\treturn new Section(sectionText)\n\t\t\t})\n\n\t\t\tvar modifiedSections = []\n\t\t\tvar sectionsToRemove = []\n\t\t\tinsertBeforeSection = undefined\n\n\t\t\tif (isInit) {\n\t\t\t\t// Render everything if isInit\n\t\t\t\tsectionsToRemove = sectionList\n\t\t\t\tsectionList = newSectionList\n\t\t\t\tmodifiedSections = newSectionList\n\t\t\t} else {\n\t\t\t\t// Find modified section starting from top\n\t\t\t\tvar leftIndex = sectionList.length\n\t\t\t\tsectionList.cl_some(function(section, index) {\n\t\t\t\t\tvar newSection = newSectionList[index]\n\t\t\t\t\tif (index >= newSectionList.length ||\n\t\t\t\t\t\tsection.forceHighlighting ||\n\t\t\t\t\t\t// Check text modification\n\t\t\t\t\t\tsection.text !== newSection.text ||\n\t\t\t\t\t\t// Check that section has not been detached or moved\n\t\t\t\t\t\tsection.elt.parentNode !== contentElt ||\n\t\t\t\t\t\t// Check also the content since nodes can be injected in sections via copy/paste\n\t\t\t\t\t\tsection.elt.textContent !== newSection.text) {\n\t\t\t\t\t\tleftIndex = index\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\t// Find modified section starting from bottom\n\t\t\t\tvar rightIndex = -sectionList.length\n\t\t\t\tsectionList.slice().reverse().cl_some(function(section, index) {\n\t\t\t\t\tvar newSection = newSectionList[newSectionList.length - index - 1]\n\t\t\t\t\tif (index >= newSectionList.length ||\n\t\t\t\t\t\tsection.forceHighlighting ||\n\t\t\t\t\t\t// Check modified\n\t\t\t\t\t\tsection.text !== newSection.text ||\n\t\t\t\t\t\t// Check that section has not been detached or moved\n\t\t\t\t\t\tsection.elt.parentNode !== contentElt ||\n\t\t\t\t\t\t// Check also the content since nodes can be injected in sections via copy/paste\n\t\t\t\t\t\tsection.elt.textContent !== newSection.text) {\n\t\t\t\t\t\trightIndex = -index\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tif (leftIndex - rightIndex > sectionList.length) {\n\t\t\t\t\t// Prevent overlap\n\t\t\t\t\trightIndex = leftIndex - sectionList.length\n\t\t\t\t}\n\n\t\t\t\tvar leftSections = sectionList.slice(0, leftIndex)\n\t\t\t\tmodifiedSections = newSectionList.slice(leftIndex, newSectionList.length + rightIndex)\n\t\t\t\tvar rightSections = sectionList.slice(sectionList.length + rightIndex, sectionList.length)\n\t\t\t\tinsertBeforeSection = rightSections[0]\n\t\t\t\tsectionsToRemove = sectionList.slice(leftIndex, sectionList.length + rightIndex)\n\t\t\t\tsectionList = leftSections.concat(modifiedSections).concat(rightSections)\n\t\t\t}\n\n\t\t\tvar newSectionEltList = editor.$document.createDocumentFragment()\n\t\t\tmodifiedSections.cl_each(function(section) {\n\t\t\t\tsection.forceHighlighting = false\n\t\t\t\thighlight(section)\n\t\t\t\tnewSectionEltList.appendChild(section.elt)\n\t\t\t})\n\t\t\teditor.watcher.noWatch(function() {\n\t\t\t\tif (isInit) {\n\t\t\t\t\tcontentElt.innerHTML = ''\n\t\t\t\t\tcontentElt.appendChild(newSectionEltList)\n\t\t\t\t\treturn this.addTrailingNode()\n\t\t\t\t}\n\n\t\t\t\t// Remove outdated sections\n\t\t\t\tsectionsToRemove.cl_each(function(section) {\n\t\t\t\t\t// section may be already removed\n\t\t\t\t\tsection.elt.parentNode === contentElt && contentElt.removeChild(section.elt)\n\t\t\t\t\t// To detect sections that come back with built-in undo\n\t\t\t\t\tsection.elt.section = undefined\n\t\t\t\t})\n\n\t\t\t\tif (insertBeforeSection !== undefined) {\n\t\t\t\t\tcontentElt.insertBefore(newSectionEltList, insertBeforeSection.elt)\n\t\t\t\t} else {\n\t\t\t\t\tcontentElt.appendChild(newSectionEltList)\n\t\t\t\t}\n\n\t\t\t\t// Remove unauthorized nodes (text nodes outside of sections or duplicated sections via copy/paste)\n\t\t\t\tvar childNode = contentElt.firstChild\n\t\t\t\twhile (childNode) {\n\t\t\t\t\tvar nextNode = childNode.nextSibling\n\t\t\t\t\tif (!childNode.section) {\n\t\t\t\t\t\tcontentElt.removeChild(childNode)\n\t\t\t\t\t}\n\t\t\t\t\tchildNode = nextNode\n\t\t\t\t}\n\t\t\t\tthis.addTrailingNode()\n\t\t\t\tself.$trigger('highlighted')\n\t\t\t\teditor.selectionMgr.restoreSelection()\n\t\t\t\teditor.selectionMgr.updateCursorCoordinates()\n\t\t\t}.cl_bind(this))\n\n\t\t\treturn sectionList\n\t\t}\n\n\t\tfunction highlight(section) {\n\t\t\tvar html = editor.options.highlighter(section.text).replace(/\\n/g, lfHtml)\n\t\t\tvar sectionElt = editor.$document.createElement('div')\n\t\t\tsectionElt.className = 'cledit-section'\n\t\t\tsectionElt.innerHTML = html\n\t\t\tsection.setElement(sectionElt)\n\t\t\tself.$trigger('sectionHighlighted', section)\n\t\t}\n\t}\n\n\tcledit.Highlighter = Highlighter\n})(window.cledit)\n","(function(cledit) {\n\tfunction Keystroke(handler, priority) {\n\t\tthis.handler = handler\n\t\tthis.priority = priority || 100\n\t}\n\n\tcledit.Keystroke = Keystroke\n\n\tvar clearNewline, charTypes = Object.create(null)\n\n\t// Word separators, as in Sublime Text\n\t'./\\\\()\"\\'-:,.;<>~!@#$%^&*|+=[]{}`~?'.split('').cl_each(function(wordSeparator) {\n\t\tcharTypes[wordSeparator] = 'wordSeparator'\n\t})\n\tcharTypes[' '] = 'space'\n\tcharTypes['\\t'] = 'space'\n\tcharTypes['\\n'] = 'newLine'\n\n\tfunction getNextWordOffset(text, offset, isBackward) {\n\t\tvar previousType\n\t\twhile ((isBackward && offset > 0) || (!isBackward && offset < text.length)) {\n\t\t\tvar currentType = charTypes[isBackward ? text[offset - 1] : text[offset]] || 'word'\n\t\t\tif (previousType && currentType !== previousType) {\n\t\t\t\tif (previousType === 'word' || currentType === 'space' || previousType === 'newLine' || currentType === 'newLine') {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tpreviousType = currentType\n\t\t\tisBackward ? offset-- : offset++\n\t\t}\n\t\treturn offset\n\t}\n\n\tcledit.defaultKeystrokes = [\n\n\t\tnew Keystroke(function(evt, state, editor) {\n\t\t\tif ((!evt.ctrlKey && !evt.metaKey) || evt.altKey) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar keyCode = evt.charCode || evt.keyCode\n\t\t\tvar keyCodeChar = String.fromCharCode(keyCode).toLowerCase()\n\t\t\tvar action\n\t\t\tswitch (keyCodeChar) {\n\t\t\t\tcase 'y':\n\t\t\t\t\taction = 'redo'\n\t\t\t\t\tbreak\n\t\t\t\tcase 'z':\n\t\t\t\t\taction = evt.shiftKey ? 'redo' : 'undo'\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (action) {\n\t\t\t\tevt.preventDefault()\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\teditor.undoMgr[action]()\n\t\t\t\t}, 10)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}),\n\n\t\tnew Keystroke(function(evt, state) {\n\t\t\tif (evt.which !== 9 /* tab */ || evt.metaKey || evt.ctrlKey) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfunction strSplice(str, i, remove, add) {\n\t\t\t\tremove = +remove || 0\n\t\t\t\tadd = add || ''\n\t\t\t\treturn str.slice(0, i) + add + str.slice(i + remove)\n\t\t\t}\n\n\t\t\tevt.preventDefault()\n\t\t\tvar isInverse = evt.shiftKey\n\t\t\tvar lf = state.before.lastIndexOf('\\n') + 1\n\t\t\tif (isInverse) {\n\t\t\t\tif (/\\s/.test(state.before.charAt(lf))) {\n\t\t\t\t\tstate.before = strSplice(state.before, lf, 1)\n\t\t\t\t}\n\t\t\t\tstate.selection = state.selection.replace(/^[ \\t]/gm, '')\n\t\t\t} else {\n\t\t\t\tif (state.selection) {\n\t\t\t\t\tstate.before = strSplice(state.before, lf, 0, '\\t')\n\t\t\t\t\tstate.selection = state.selection.replace(/\\n(?=[\\s\\S])/g, '\\n\\t')\n\t\t\t\t} else {\n\t\t\t\t\tstate.before += '\\t'\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}),\n\n\t\tnew Keystroke(function(evt, state, editor) {\n\t\t\tif (evt.which !== 13 /* enter */) {\n\t\t\t\tclearNewline = false\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tevt.preventDefault()\n\t\t\tvar lf = state.before.lastIndexOf('\\n') + 1\n\t\t\tif (clearNewline) {\n\t\t\t\tstate.before = state.before.substring(0, lf)\n\t\t\t\tstate.selection = ''\n\t\t\t\tclearNewline = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tclearNewline = false\n\t\t\tvar previousLine = state.before.slice(lf)\n\t\t\tvar indent = previousLine.match(/^\\s*/)[0]\n\t\t\tif (indent.length) {\n\t\t\t\tclearNewline = true\n\t\t\t}\n\n\t\t\teditor.undoMgr.setCurrentMode('single')\n\t\t\tstate.before += '\\n' + indent\n\t\t\tstate.selection = ''\n\t\t\treturn true\n\t\t}),\n\n\t\tnew Keystroke(function(evt, state, editor) {\n\t\t\tif (evt.which !== 8 /* backspace */ && evt.which !== 46 /* delete */) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\teditor.undoMgr.setCurrentMode('delete')\n\t\t\tif (!state.selection) {\n\t\t\t\tvar isJump = (cledit.Utils.isMac && evt.altKey) || (!cledit.Utils.isMac && evt.ctrlKey)\n\t\t\t\tif (isJump) {\n\t\t\t\t\t// Custom kill word behavior\n\t\t\t\t\tvar text = state.before + state.after\n\t\t\t\t\tvar offset = getNextWordOffset(text, state.before.length, evt.which === 8)\n\t\t\t\t\tif (evt.which === 8) {\n\t\t\t\t\t\tstate.before = state.before.slice(0, offset)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.after = state.after.slice(offset - text.length)\n\t\t\t\t\t}\n\t\t\t\t\tevt.preventDefault()\n\t\t\t\t\treturn true\n\t\t\t\t} else if (evt.which === 8 && state.before.slice(-1) === '\\n') {\n                    // Special treatment for end of lines\n\t\t\t\t\tstate.before = state.before.slice(0, -1)\n\t\t\t\t\tevt.preventDefault()\n\t\t\t\t\treturn true\n\t\t\t\t} else if (evt.which === 46 && state.after.slice(0, 1) === '\\n') {\n\t\t\t\t\tstate.after = state.after.slice(1)\n\t\t\t\t\tevt.preventDefault()\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate.selection = ''\n\t\t\t\tevt.preventDefault()\n\t\t\t\treturn true\n\t\t\t}\n\t\t}),\n\n\t\tnew Keystroke(function(evt, state, editor) {\n\t\t\tif (evt.which !== 37 /* left arrow */ && evt.which !== 39 /* right arrow */) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar isJump = (cledit.Utils.isMac && evt.altKey) || (!cledit.Utils.isMac && evt.ctrlKey)\n\t\t\tif (!isJump) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Custom jump behavior\n\t\t\tvar textContent = editor.getContent()\n\t\t\tvar offset = getNextWordOffset(textContent, editor.selectionMgr.selectionEnd, evt.which === 37)\n\t\t\tif (evt.shiftKey) {\n\t\t\t\t// rebuild the state completely\n\t\t\t\tvar min = Math.min(editor.selectionMgr.selectionStart, offset)\n\t\t\t\tvar max = Math.max(editor.selectionMgr.selectionStart, offset)\n\t\t\t\tstate.before = textContent.slice(0, min)\n\t\t\t\tstate.after = textContent.slice(max)\n\t\t\t\tstate.selection = textContent.slice(min, max)\n\t\t\t\tstate.isBackwardSelection = editor.selectionMgr.selectionStart > offset\n\t\t\t} else {\n\t\t\t\tstate.before = textContent.slice(0, offset)\n\t\t\t\tstate.after = textContent.slice(offset)\n\t\t\t\tstate.selection = ''\n\t\t\t}\n\t\t\tevt.preventDefault()\n\t\t\treturn true\n\t\t})\n\t]\n})(window.cledit)\n","(function(cledit) {\n\tvar DIFF_DELETE = -1\n\tvar DIFF_INSERT = 1\n\tvar DIFF_EQUAL = 0\n\n\tvar idCounter = 0\n\n\tfunction Marker(offset) {\n\t\tthis.id = idCounter++\n\t\tthis.offset = offset\n\t}\n\n\tMarker.prototype.adjustOffset = function(diffs) {\n\t\tvar startOffset = 0\n\t\tdiffs.cl_each(function(diff) {\n\t\t\tvar diffType = diff[0]\n\t\t\tvar diffText = diff[1]\n\t\t\tvar diffOffset = diffText.length\n\t\t\tswitch (diffType) {\n\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\tstartOffset += diffOffset\n\t\t\t\t\tbreak\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tif (this.offset > startOffset) {\n\t\t\t\t\t\tthis.offset += diffOffset\n\t\t\t\t\t}\n\t\t\t\t\tstartOffset += diffOffset\n\t\t\t\t\tbreak\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tif (this.offset > startOffset) {\n\t\t\t\t\t\tthis.offset -= diffOffset\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}.cl_bind(this))\n\t}\n\n\tcledit.Marker = Marker\n})(window.cledit)\n","/* jshint -W084 */\n(function(cledit) {\n\tfunction SelectionMgr(editor) {\n\t\tvar debounce = cledit.Utils.debounce\n\t\tvar contentElt = editor.$contentElt\n\t\tvar scrollElt = editor.$scrollElt\n\t\tcledit.Utils.createEventHooks(this)\n\n\t\tvar self = this\n\t\tvar lastSelectionStart = 0,\n\t\t\tlastSelectionEnd = 0\n\t\tthis.selectionStart = 0\n\t\tthis.selectionEnd = 0\n\t\tthis.cursorCoordinates = {}\n\t\tthis.adjustTop = 0\n\t\tthis.adjustBottom = 0\n\n\t\tthis.findContainer = function(offset) {\n\t\t\tvar result = cledit.Utils.findContainer(contentElt, offset)\n\t\t\tif (result.container.nodeValue === '\\n') {\n\t\t\t\tvar hdLfElt = result.container.parentNode\n\t\t\t\tif (hdLfElt.className === 'hd-lf' && hdLfElt.previousSibling && hdLfElt.previousSibling.tagName === 'BR') {\n\t\t\t\t\tresult.container = hdLfElt.parentNode\n\t\t\t\t\tresult.offsetInContainer = Array.prototype.indexOf.call(result.container.childNodes, result.offsetInContainer === 0 ? hdLfElt.previousSibling : hdLfElt)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\n\t\tthis.createRange = function(start, end) {\n\t\t\tvar range = editor.$document.createRange()\n\t\t\tif (start === end) {\n\t\t\t\tend = start = isNaN(start) ? start : this.findContainer(start < 0 ? 0 : start)\n\t\t\t} else {\n\t\t\t\tstart = isNaN(start) ? start : this.findContainer(start < 0 ? 0 : start)\n\t\t\t\tend = isNaN(end) ? end : this.findContainer(end < 0 ? 0 : end)\n\t\t\t}\n\t\t\trange.setStart(start.container, start.offsetInContainer)\n\t\t\trange.setEnd(end.container, end.offsetInContainer)\n\t\t\treturn range\n\t\t}\n\n\t\tvar adjustScroll\n\t\tvar debouncedUpdateCursorCoordinates = debounce(function() {\n\t\t\tvar coordinates = this.getCoordinates(this.selectionEnd, this.selectionEndContainer, this.selectionEndOffset)\n\t\t\tif (this.cursorCoordinates.top !== coordinates.top ||\n\t\t\t\tthis.cursorCoordinates.height !== coordinates.height ||\n\t\t\t\tthis.cursorCoordinates.left !== coordinates.left\n\t\t\t) {\n\t\t\t\tthis.cursorCoordinates = coordinates\n\t\t\t\tthis.$trigger('cursorCoordinatesChanged', coordinates)\n\t\t\t}\n\t\t\tif (adjustScroll) {\n\t\t\t\tvar adjustTop, adjustBottom\n\t\t\t\tadjustTop = adjustBottom = scrollElt.clientHeight / 2 * editor.options.cursorFocusRatio\n\t\t\t\tadjustTop = this.adjustTop || adjustTop\n\t\t\t\tadjustBottom = this.adjustBottom || adjustTop\n\t\t\t\tif (adjustTop && adjustBottom) {\n\t\t\t\t\tvar cursorMinY = scrollElt.scrollTop + adjustTop\n\t\t\t\t\tvar cursorMaxY = scrollElt.scrollTop + scrollElt.clientHeight - adjustBottom\n\t\t\t\t\tif (this.cursorCoordinates.top < cursorMinY) {\n\t\t\t\t\t\tscrollElt.scrollTop += this.cursorCoordinates.top - cursorMinY\n\t\t\t\t\t} else if (this.cursorCoordinates.top + this.cursorCoordinates.height > cursorMaxY) {\n\t\t\t\t\t\tscrollElt.scrollTop += this.cursorCoordinates.top + this.cursorCoordinates.height - cursorMaxY\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tadjustScroll = false\n\t\t}.cl_bind(this))\n\n\t\tthis.updateCursorCoordinates = function(adjustScrollParam) {\n\t\t\tadjustScroll = adjustScroll || adjustScrollParam\n\t\t\tdebouncedUpdateCursorCoordinates()\n\t\t}\n\n\t\tvar oldSelectionRange\n\n\t\tfunction checkSelection(selectionRange) {\n\t\t\tif (!oldSelectionRange ||\n\t\t\t\toldSelectionRange.startContainer !== selectionRange.startContainer ||\n\t\t\t\toldSelectionRange.startOffset !== selectionRange.startOffset ||\n\t\t\t\toldSelectionRange.endContainer !== selectionRange.endContainer ||\n\t\t\t\toldSelectionRange.endOffset !== selectionRange.endOffset\n\t\t\t) {\n\t\t\t\toldSelectionRange = selectionRange\n\t\t\t\tself.$trigger('selectionChanged', self.selectionStart, self.selectionEnd, selectionRange)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tthis.restoreSelection = function() {\n\t\t\tvar min = Math.min(this.selectionStart, this.selectionEnd)\n\t\t\tvar max = Math.max(this.selectionStart, this.selectionEnd)\n\t\t\tvar selectionRange = this.createRange(min, max)\n\t\t\tvar selection = editor.$window.getSelection()\n\t\t\tselection.removeAllRanges()\n\t\t\tvar isBackward = this.selectionStart > this.selectionEnd\n\t\t\tif (isBackward && selection.extend) {\n\t\t\t\tvar endRange = selectionRange.cloneRange()\n\t\t\t\tendRange.collapse(false)\n\t\t\t\tselection.addRange(endRange)\n\t\t\t\tselection.extend(selectionRange.startContainer, selectionRange.startOffset)\n\t\t\t} else {\n\t\t\t\tselection.addRange(selectionRange)\n\t\t\t}\n\t\t\tcheckSelection(selectionRange)\n\t\t\treturn selectionRange\n\t\t}\n\n\t\tvar saveLastSelection = debounce(function() {\n\t\t\tlastSelectionStart = self.selectionStart\n\t\t\tlastSelectionEnd = self.selectionEnd\n\t\t}, 50)\n\n\t\tfunction setSelection(start, end) {\n\t\t\tif (start === undefined) {\n\t\t\t\tstart = self.selectionStart\n\t\t\t}\n\t\t\tif (start < 0) {\n\t\t\t\tstart = 0\n\t\t\t}\n\t\t\tif (end === undefined) {\n\t\t\t\tend = this.selectionEnd\n\t\t\t}\n\t\t\tif (end < 0) {\n\t\t\t\tend = 0\n\t\t\t}\n\t\t\tself.selectionStart = start\n\t\t\tself.selectionEnd = end\n\t\t\tsaveLastSelection()\n\t\t}\n\n\t\tthis.setSelectionStartEnd = function(start, end, focus) {\n\t\t\tsetSelection(start, end)\n\t\t\treturn focus !== false && this.restoreSelection()\n\t\t}\n\n\t\tthis.saveSelectionState = (function() {\n\t\t\t// Credit: https://github.com/timdown/rangy\n\t\t\tfunction arrayContains(arr, val) {\n\t\t\t\tvar i = arr.length\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (arr[i] === val) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tfunction getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n\t\t\t\tvar p, n = selfIsAncestor ? node : node.parentNode\n\t\t\t\twhile (n) {\n\t\t\t\t\tp = n.parentNode\n\t\t\t\t\tif (p === ancestor) {\n\t\t\t\t\t\treturn n\n\t\t\t\t\t}\n\t\t\t\t\tn = p\n\t\t\t\t}\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\tfunction getNodeIndex(node) {\n\t\t\t\tvar i = 0\n\t\t\t\twhile ((node = node.previousSibling)) {\n\t\t\t\t\t++i\n\t\t\t\t}\n\t\t\t\treturn i\n\t\t\t}\n\n\t\t\tfunction getCommonAncestor(node1, node2) {\n\t\t\t\tvar ancestors = [],\n\t\t\t\t\tn\n\t\t\t\tfor (n = node1; n; n = n.parentNode) {\n\t\t\t\t\tancestors.push(n)\n\t\t\t\t}\n\n\t\t\t\tfor (n = node2; n; n = n.parentNode) {\n\t\t\t\t\tif (arrayContains(ancestors, n)) {\n\t\t\t\t\t\treturn n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\tfunction comparePoints(nodeA, offsetA, nodeB, offsetB) {\n\t\t\t\t// See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n\t\t\t\tvar nodeC, root, childA, childB, n\n\t\t\t\tif (nodeA === nodeB) {\n\t\t\t\t\t// Case 1: nodes are the same\n\t\t\t\t\treturn offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1\n\t\t\t\t} else if ((nodeC = getClosestAncestorIn(nodeB, nodeA, true))) {\n\t\t\t\t\t// Case 2: node C (container B or an ancestor) is a child node of A\n\t\t\t\t\treturn offsetA <= getNodeIndex(nodeC) ? -1 : 1\n\t\t\t\t} else if ((nodeC = getClosestAncestorIn(nodeA, nodeB, true))) {\n\t\t\t\t\t// Case 3: node C (container A or an ancestor) is a child node of B\n\t\t\t\t\treturn getNodeIndex(nodeC) < offsetB ? -1 : 1\n\t\t\t\t} else {\n\t\t\t\t\troot = getCommonAncestor(nodeA, nodeB)\n\t\t\t\t\tif (!root) {\n\t\t\t\t\t\tthrow new Error('comparePoints error: nodes have no common ancestor')\n\t\t\t\t\t}\n\n\t\t\t\t\t// Case 4: containers are siblings or descendants of siblings\n\t\t\t\t\tchildA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true)\n\t\t\t\t\tchildB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true)\n\n\t\t\t\t\tif (childA === childB) {\n\t\t\t\t\t\t// This shouldn't be possible\n\t\t\t\t\t\tthrow module.createError('comparePoints got to case 4 and childA and childB are the same!')\n\t\t\t\t\t} else {\n\t\t\t\t\t\tn = root.firstChild\n\t\t\t\t\t\twhile (n) {\n\t\t\t\t\t\t\tif (n === childA) {\n\t\t\t\t\t\t\t\treturn -1\n\t\t\t\t\t\t\t} else if (n === childB) {\n\t\t\t\t\t\t\t\treturn 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn = n.nextSibling\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction save() {\n\t\t\t\tvar selectionStart = self.selectionStart\n\t\t\t\tvar selectionEnd = self.selectionEnd\n\t\t\t\tvar selection = editor.$window.getSelection()\n\t\t\t\tvar result\n\t\t\t\tif (selection.rangeCount > 0) {\n\t\t\t\t\tvar selectionRange = selection.getRangeAt(0)\n\t\t\t\t\tvar node = selectionRange.startContainer\n\t\t\t\t\tif ((contentElt.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) || contentElt === node) {\n\t\t\t\t\t\tvar offset = selectionRange.startOffset\n\t\t\t\t\t\tif (node.firstChild && offset > 0) {\n\t\t\t\t\t\t\tnode = node.childNodes[offset - 1]\n\t\t\t\t\t\t\toffset = node.textContent.length\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar container = node\n\t\t\t\t\t\twhile (node !== contentElt) {\n\t\t\t\t\t\t\twhile ((node = node.previousSibling)) {\n\t\t\t\t\t\t\t\toffset += (node.textContent || '').length\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode = container = container.parentNode\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar selectionText = selectionRange + ''\n\t\t\t\t\t\t// Fix end of line when only br is selected\n\t\t\t\t\t\tvar brElt = selectionRange.endContainer.firstChild\n\t\t\t\t\t\tif (brElt && brElt.tagName === 'BR' && selectionRange.endOffset === 1) {\n\t\t\t\t\t\t\tselectionText += '\\n'\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (comparePoints(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset) === 1) {\n\t\t\t\t\t\t\tselectionStart = offset + selectionText.length\n\t\t\t\t\t\t\tselectionEnd = offset\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectionStart = offset\n\t\t\t\t\t\t\tselectionEnd = offset + selectionText.length\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (selectionStart === selectionEnd && selectionStart === editor.getContent().length) {\n\t\t\t\t\t\t\t// If cursor is after the trailingNode\n\t\t\t\t\t\t\tselectionStart = --selectionEnd\n\t\t\t\t\t\t\tresult = self.setSelectionStartEnd(selectionStart, selectionEnd)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetSelection(selectionStart, selectionEnd)\n\t\t\t\t\t\t\tresult = checkSelection(selectionRange)\n\t\t\t\t\t\t\tresult = result || lastSelectionStart !== self.selectionStart // selectionRange doesn't change when selection is at the start of a section\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t}\n\n\t\t\tfunction saveCheckChange() {\n\t\t\t\treturn save() && (lastSelectionStart !== self.selectionStart || lastSelectionEnd !== self.selectionEnd)\n\t\t\t}\n\n\t\t\tvar nextTickAdjustScroll = false\n\t\t\tvar debouncedSave = debounce(function() {\n\t\t\t\tself.updateCursorCoordinates(saveCheckChange() && nextTickAdjustScroll)\n\t\t\t\t// In some cases we have to wait a little longer to see the selection change (Cmd+A on Chrome OSX)\n\t\t\t\tlongerDebouncedSave()\n\t\t\t})\n\t\t\tvar longerDebouncedSave = debounce(function() {\n\t\t\t\tself.updateCursorCoordinates(saveCheckChange() && nextTickAdjustScroll)\n\t\t\t\tnextTickAdjustScroll = false\n\t\t\t}, 10)\n\n\t\t\treturn function(debounced, adjustScroll, forceAdjustScroll) {\n\t\t\t\tif (forceAdjustScroll) {\n\t\t\t\t\tlastSelectionStart = undefined\n\t\t\t\t\tlastSelectionEnd = undefined\n\t\t\t\t}\n\t\t\t\tif (debounced) {\n\t\t\t\t\tnextTickAdjustScroll = nextTickAdjustScroll || adjustScroll\n\t\t\t\t\treturn debouncedSave()\n\t\t\t\t} else {\n\t\t\t\t\tsave()\n\t\t\t\t}\n\t\t\t}\n\t\t})()\n\n\t\tthis.getSelectedText = function() {\n\t\t\tvar min = Math.min(this.selectionStart, this.selectionEnd)\n\t\t\tvar max = Math.max(this.selectionStart, this.selectionEnd)\n\t\t\treturn editor.getContent().substring(min, max)\n\t\t}\n\n\t\tthis.getCoordinates = function(inputOffset, container, offsetInContainer) {\n\t\t\tif (!container) {\n\t\t\t\tvar offset = this.findContainer(inputOffset)\n\t\t\t\tcontainer = offset.container\n\t\t\t\toffsetInContainer = offset.offsetInContainer\n\t\t\t}\n\t\t\tvar containerElt = container\n\t\t\tif (!containerElt.hasChildNodes()) {\n\t\t\t\tcontainerElt = container.parentNode\n\t\t\t}\n\t\t\tvar isInvisible = false\n\t\t\tvar index = editor.$allElements.indexOf(containerElt)\n\t\t\twhile (containerElt.offsetHeight === 0 && index > 0) {\n\t\t\t\tisInvisible = true\n\t\t\t\tcontainerElt = editor.$allElements[--index]\n\t\t\t}\n\t\t\tvar rect,\n\t\t\t\tcontentRect,\n\t\t\t\tleft = 'left'\n\t\t\tif (isInvisible || container.textContent === '\\n') {\n\t\t\t\trect = containerElt.getBoundingClientRect()\n\t\t\t} else {\n\t\t\t\tvar selectedChar = editor.getContent()[inputOffset]\n\t\t\t\tvar startOffset = {\n\t\t\t\t\tcontainer: container,\n\t\t\t\t\toffsetInContainer: offsetInContainer\n\t\t\t\t}\n\t\t\t\tvar endOffset = {\n\t\t\t\t\tcontainer: container,\n\t\t\t\t\toffsetInContainer: offsetInContainer\n\t\t\t\t}\n\t\t\t\tif (inputOffset > 0 && (selectedChar === undefined || selectedChar === '\\n')) {\n\t\t\t\t\tleft = 'right'\n\t\t\t\t\tif (startOffset.offsetInContainer === 0) {\n\t\t\t\t\t\t// Need to calculate offset-1\n\t\t\t\t\t\tstartOffset = inputOffset - 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstartOffset.offsetInContainer -= 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (endOffset.offsetInContainer === container.textContent.length) {\n\t\t\t\t\t\t// Need to calculate offset+1\n\t\t\t\t\t\tendOffset = inputOffset + 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\tendOffset.offsetInContainer += 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar range = this.createRange(startOffset, endOffset)\n\t\t\t\trect = range.getBoundingClientRect()\n\t\t\t}\n\t\t\tcontentRect = contentElt.getBoundingClientRect()\n\t\t\treturn {\n\t\t\t\ttop: Math.round(rect.top - contentRect.top + contentElt.scrollTop),\n\t\t\t\theight: Math.round(rect.height),\n\t\t\t\tleft: Math.round(rect[left] - contentRect.left + contentElt.scrollLeft)\n\t\t\t}\n\t\t}\n\n\t\tthis.getClosestWordOffset = function(offset) {\n\t\t\tvar offsetStart = 0\n\t\t\tvar offsetEnd = 0\n\t\t\tvar nextOffset = 0\n\t\t\teditor.getContent().split(/\\s/).cl_some(function(word) {\n\t\t\t\tif (word) {\n\t\t\t\t\toffsetStart = nextOffset\n\t\t\t\t\toffsetEnd = nextOffset + word.length\n\t\t\t\t\tif (offsetEnd > offset) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnextOffset += word.length + 1\n\t\t\t})\n\t\t\treturn {\n\t\t\t\tstart: offsetStart,\n\t\t\t\tend: offsetEnd\n\t\t\t}\n\t\t}\n\t}\n\n\tcledit.SelectionMgr = SelectionMgr\n})(window.cledit)\n","/* jshint -W084, -W099 */\n(function(cledit, diff_match_patch) {\n\tfunction UndoMgr(editor, options) {\n\t\tcledit.Utils.createEventHooks(this)\n\n\t\toptions = ({\n\t\t\tundoStackMaxSize: 200,\n\t\t\tbufferStateUntilIdle: 1000\n\t\t}).cl_extend(options || {})\n\n\t\tvar self = this\n\t\tvar selectionMgr\n\t\tvar undoStack = []\n\t\tvar redoStack = []\n\t\tvar currentState\n\t\tvar previousPatches = []\n\t\tvar currentPatches = []\n\t\tvar debounce = cledit.Utils.debounce\n\n\t\tfunction State() {}\n\n\t\tfunction addToStack(stack) {\n\t\t\treturn function() {\n\t\t\t\tstack.push(this)\n\t\t\t\tthis.patches = previousPatches\n\t\t\t\tpreviousPatches = []\n\t\t\t}\n\t\t}\n\n\t\tState.prototype.addToUndoStack = addToStack(undoStack)\n\t\tState.prototype.addToRedoStack = addToStack(redoStack)\n\n\t\tfunction StateMgr() {\n\t\t\tvar currentTime, lastTime\n\t\t\tvar lastMode\n\n\t\t\tthis.isBufferState = function() {\n\t\t\t\tcurrentTime = Date.now()\n\t\t\t\treturn this.currentMode !== 'single' &&\n\t\t\t\t\tthis.currentMode === lastMode &&\n\t\t\t\t\tcurrentTime - lastTime < options.bufferStateUntilIdle\n\t\t\t}\n\n\t\t\tthis.setDefaultMode = function(mode) {\n\t\t\t\tthis.currentMode = this.currentMode || mode\n\t\t\t}\n\n\t\t\tthis.resetMode = function() {\n\t\t\t\tstateMgr.currentMode = undefined\n\t\t\t\tlastMode = undefined\n\t\t\t}\n\n\t\t\tthis.saveMode = function() {\n\t\t\t\tlastMode = this.currentMode\n\t\t\t\tthis.currentMode = undefined\n\t\t\t\tlastTime = currentTime\n\t\t\t}\n\t\t}\n\n\t\tvar stateMgr = new StateMgr()\n\t\tthis.setCurrentMode = function(mode) {\n\t\t\tstateMgr.currentMode = mode\n\t\t}\n\t\tthis.setDefaultMode = stateMgr.setDefaultMode.cl_bind(stateMgr)\n\n\t\tvar diffMatchPatch = new diff_match_patch()\n\n\t\tthis.addPatches = function(patches) {\n\t\t\tcurrentPatches.push.apply(currentPatches, patches)\n\t\t}\n\n\t\tfunction saveCurrentPatches() {\n\t\t\t// Move currentPatches into previousPatches\n\t\t\tArray.prototype.push.apply(previousPatches, currentPatches)\n\t\t\tcurrentPatches = []\n\t\t}\n\n\t\tthis.saveState = debounce(function() {\n\t\t\tredoStack.length = 0\n\t\t\tif (!stateMgr.isBufferState()) {\n\t\t\t\tcurrentState.addToUndoStack()\n\n\t\t\t\t// Limit the size of the stack\n\t\t\t\twhile (undoStack.length > options.undoStackMaxSize) {\n\t\t\t\t\tundoStack.shift()\n\t\t\t\t}\n\t\t\t}\n\t\t\tsaveCurrentPatches()\n\t\t\tcurrentState = new State()\n\t\t\tstateMgr.saveMode()\n\t\t\tself.$trigger('undoStateChange')\n\t\t})\n\n\t\tthis.canUndo = function() {\n\t\t\treturn !!undoStack.length\n\t\t}\n\n\t\tthis.canRedo = function() {\n\t\t\treturn !!redoStack.length\n\t\t}\n\n\t\tfunction restoreState(patches, isForward) {\n\t\t\t// Update editor\n\t\t\tvar content = editor.getContent()\n\t\t\tif (!isForward) {\n\t\t\t\tpatches = diffMatchPatch.patch_deepCopy(patches).reverse()\n\t\t\t\tpatches.cl_each(function(patch) {\n\t\t\t\t\tpatch.diffs.cl_each(function(diff) {\n\t\t\t\t\t\tdiff[0] = -diff[0]\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tvar newContent = diffMatchPatch.patch_apply(patches, content)[0]\n\t\t\tvar range = editor.setContent(newContent, true)\n\n\t\t\tvar diffs = diffMatchPatch.diff_main(content, newContent)\n\t\t\teditor.$markers.cl_each(function(marker) {\n\t\t\t\tmarker.adjustOffset(diffs)\n\t\t\t})\n\n\t\t\tselectionMgr.setSelectionStartEnd(range.end, range.end)\n\t\t\tselectionMgr.updateCursorCoordinates(true)\n\n\t\t\tstateMgr.resetMode()\n\t\t\tself.$trigger('undoStateChange')\n\t\t\teditor.adjustCursorPosition()\n\t\t}\n\n\t\tthis.undo = function() {\n\t\t\tvar state = undoStack.pop()\n\t\t\tif (!state) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsaveCurrentPatches()\n\t\t\tcurrentState.addToRedoStack()\n\t\t\trestoreState(currentState.patches)\n\t\t\tpreviousPatches = state.patches\n\t\t\tcurrentState = state\n\t\t}\n\n\t\tthis.redo = function() {\n\t\t\tvar state = redoStack.pop()\n\t\t\tif (!state) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrentState.addToUndoStack()\n\t\t\trestoreState(state.patches, true)\n\t\t\tpreviousPatches = state.patches\n\t\t\tcurrentState = state\n\t\t}\n\n\t\tthis.init = function() {\n\t\t\tselectionMgr = editor.selectionMgr\n\t\t\tif (!currentState) {\n\t\t\t\tcurrentState = new State()\n\t\t\t}\n\t\t}\n\t}\n\n\tcledit.UndoMgr = UndoMgr\n})(window.cledit, window.diff_match_patch)\n","(function(cledit) {\n\tvar Utils = {\n\t\tisGecko: 'MozAppearance' in document.documentElement.style,\n\t\tisWebkit: 'WebkitAppearance' in document.documentElement.style,\n\t\tisMsie: 'msTransform' in document.documentElement.style,\n\t\tisMac: navigator.userAgent.indexOf('Mac OS X') !== -1\n\t}\n\n\t// Faster than setTimeout(0). Credit: http://dbaron.org/log/20100309-faster-timeouts\n\tUtils.defer = (function() {\n\t\tvar timeouts = [],\n\t\t\tmessageName = 'deferMsg'\n\t\twindow.addEventListener('message', function(evt) {\n\t\t\tif (evt.source === window && evt.data === messageName) {\n\t\t\t\tevt.stopPropagation()\n\t\t\t\tif (timeouts.length > 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttimeouts.shift()()\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\twindow.console.error(e.message, e.stack)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\treturn function(fn) {\n\t\t\ttimeouts.push(fn)\n\t\t\twindow.postMessage(messageName, '*')\n\t\t}\n\t})()\n\n\tUtils.debounce = function(func, wait) {\n\t\tvar timeoutId, isExpected\n\t\treturn wait ?\n\t\t\tfunction() {\n\t\t\t\tclearTimeout(timeoutId)\n\t\t\t\ttimeoutId = setTimeout(func, wait)\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\tif (!isExpected) {\n\t\t\t\t\tisExpected = true\n\t\t\t\t\tUtils.defer(function() {\n\t\t\t\t\t\tisExpected = false\n\t\t\t\t\t\tfunc()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tUtils.createEventHooks = function(object) {\n\t\tvar listenerMap = {}\n\t\tobject.$trigger = function(eventType) {\n\t\t\tvar listeners = listenerMap[eventType]\n\t\t\tif (listeners) {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1)\n\t\t\t\tlisteners.cl_each(function(listener) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.apply(object, args)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\twindow.console.error(e.message, e.stack)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tobject.on = function(eventType, listener) {\n\t\t\tvar listeners = listenerMap[eventType]\n\t\t\tif (!listeners) {\n\t\t\t\tlisteners = []\n\t\t\t\tlistenerMap[eventType] = listeners\n\t\t\t}\n\t\t\tlisteners.push(listener)\n\t\t}\n\t\tobject.off = function(eventType, listener) {\n\t\t\tvar listeners = listenerMap[eventType]\n\t\t\tif (listeners) {\n\t\t\t\tvar index = listeners.indexOf(listener)\n\t\t\t\tif (index > -1) {\n\t\t\t\t\tlisteners.splice(index, 1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tUtils.findContainer = function(elt, offset) {\n\t\tvar containerOffset = 0,\n\t\t\tcontainer\n\t\tdo {\n\t\t\tcontainer = elt\n\t\t\telt = elt.firstChild\n\t\t\tif (elt) {\n\t\t\t\tdo {\n\t\t\t\t\tvar len = elt.textContent.length\n\t\t\t\t\tif (containerOffset <= offset && containerOffset + len > offset) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcontainerOffset += len\n\t\t\t\t} while ((elt = elt.nextSibling))\n\t\t\t}\n\t\t} while (elt && elt.firstChild && elt.nodeType !== 3)\n\t\tif (elt) {\n\t\t\treturn {\n\t\t\t\tcontainer: elt,\n\t\t\t\toffsetInContainer: offset - containerOffset\n\t\t\t}\n\t\t}\n\t\twhile (container.lastChild) {\n\t\t\tcontainer = container.lastChild\n\t\t}\n\t\treturn {\n\t\t\tcontainer: container,\n\t\t\toffsetInContainer: container.nodeType === 3 ? container.textContent.length : 0\n\t\t}\n\t}\n\n\tcledit.Utils = Utils\n})(window.cledit)\n","(function(cledit) {\n\tfunction Watcher(editor, listener) {\n\t\tthis.isWatching = false\n\t\tvar contentObserver\n\t\tthis.startWatching = function() {\n\t\t\tthis.stopWatching()\n\t\t\tthis.isWatching = true\n\t\t\tcontentObserver = new MutationObserver(listener)\n\t\t\tcontentObserver.observe(editor.$contentElt, {\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true,\n\t\t\t\tcharacterData: true\n\t\t\t})\n\t\t}\n\t\tthis.stopWatching = function() {\n\t\t\tif (contentObserver) {\n\t\t\t\tcontentObserver.disconnect()\n\t\t\t\tcontentObserver = undefined\n\t\t\t}\n\t\t\tthis.isWatching = false\n\t\t}\n\t\tthis.noWatch = function(cb) {\n\t\t\tif (this.isWatching === true) {\n\t\t\t\tthis.stopWatching()\n\t\t\t\tcb()\n\t\t\t\treturn this.startWatching()\n\t\t\t}\n\t\t\tcb()\n\t\t}\n\t}\n\n\tcledit.Watcher = Watcher\n})(window.cledit)\n","(function() {\n\tvar charInsideUrl = '(&|[-A-Z0-9+@#/%?=~_|[\\\\]()!:,.;])',\n\t\tcharEndingUrl = '(&|[-A-Z0-9+@#/%=~_|[\\\\])])'\n\tvar urlPattern = new RegExp('(https?|ftp)(://' + charInsideUrl + '*' + charEndingUrl + ')(?=$|\\\\W)', 'gi')\n\tvar emailPattern = /(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)/gi\n\n\tvar markup = {\n\t\t'comment': /<!--[\\w\\W]*?-->/g,\n\t\t'tag': {\n\t\t\tpattern: /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/gi,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /^<\\/?[\\w:-]+/i,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t\t'namespace': /^[\\w-]+?:/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/gi,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /=|>|\"/g\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\/?>/g,\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /[\\w:-]+/g,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'namespace': /^[\\w-]+?:/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'entity': /&#?[\\da-z]{1,8};/gi\n\t}\n\n\tvar latex = {\n\t\t// A tex command e.g. \\foo\n\t\t'keyword': /\\\\(?:[^a-zA-Z]|[a-zA-Z]+)/g,\n\t\t// Curly and square braces\n\t\t'lparen': /[[({]/g,\n\t\t// Curly and square braces\n\t\t'rparen': /[\\])}]/g,\n\t\t// A comment. Tex comments start with % and go to\n\t\t// the end of the line\n\t\t'comment': /%.*/g\n\t}\n\n\twindow.mdGrammar = function(options) {\n\t\toptions = options || {}\n\t\tvar grammar = {}\n\t\tvar insideFences = options.insideFences || {}\n\t\tinsideFences['cl cl-pre'] = /`{3}|~{3}/\n\t\tif (options.fences) {\n\t\t\tgrammar['pre gfm'] = {\n\t\t\t\tpattern: /^(`{3}|~{3}).*\\n(?:[\\s\\S]*?)\\n\\1 *$/gm,\n\t\t\t\tinside: insideFences\n\t\t\t}\n\t\t}\n\t\tgrammar.li = {\n\t\t\tpattern: new RegExp(\n\t\t\t\t[\n\t\t\t\t\t'^ {0,3}(?:[*+\\\\-]|\\\\d+\\\\.)[ \\\\t].+\\\\n', // Item line\n\t\t\t\t\t'(?:',\n\t\t\t\t\t'(?:',\n\t\t\t\t\t'.*\\\\S.*\\\\n', // Non-empty line\n\t\t\t\t\t'|',\n\t\t\t\t\t'[ \\\\t]*\\\\n(?! ?\\\\S)', // Or empty line not followed by unindented line\n\t\t\t\t\t')',\n\t\t\t\t\t')*',\n\t\t\t\t].join(''),\n\t\t\t\t'gm'\n\t\t\t),\n\t\t\tinside: {\n\t\t\t\t'cl cl-li': /^[ \\t]*([*+\\-]|\\d+\\.)[ \\t]/gm\n\t\t\t}\n\t\t}\n\t\tif (options.fences) {\n\t\t\tgrammar.li.inside['pre gfm'] = {\n\t\t\t\tpattern: /^((?: {4}|\\t)+)(`{3}|~{3}).*\\n(?:[\\s\\S]*?)\\n\\1\\2\\s*$/gm,\n\t\t\t\tinside: insideFences\n\t\t\t}\n\t\t}\n\t\tgrammar.blockquote = {\n\t\t\tpattern: /^ {0,3}>.+(?:\\n[ \\t]*\\S.*)*/gm,\n\t\t\tinside: {\n\t\t\t\t'cl cl-gt': /^\\s*>/gm,\n\t\t\t\t'li': grammar.li\n\t\t\t}\n\t\t}\n\t\tgrammar['h1 alt'] = {\n\t\t\tpattern: /^.+\\n=+[ \\t]*$/gm,\n\t\t\tinside: {\n\t\t\t\t'cl cl-hash': /=+[ \\t]*$/\n\t\t\t}\n\t\t}\n\t\tgrammar['h2 alt'] = {\n\t\t\tpattern: /^.+\\n-+[ \\t]*$/gm,\n\t\t\tinside: {\n\t\t\t\t'cl cl-hash': /-+[ \\t]*$/\n\t\t\t}\n\t\t}\n\t\tfor (var i = 6; i >= 1; i--) {\n\t\t\tgrammar['h' + i] = {\n\t\t\t\tpattern: new RegExp('^#{' + i + '}[ \\t].+$', 'gm'),\n\t\t\t\tinside: {\n\t\t\t\t\t'cl cl-hash': new RegExp('^#{' + i + '}')\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.tables) {\n\t\t\tgrammar.table = {\n\t\t\t\tpattern: new RegExp(\n\t\t\t\t\t[\n\t\t\t\t\t\t'^',\n\t\t\t\t\t\t'[ ]{0,3}',\n\t\t\t\t\t\t'[|]', // Initial pipe\n\t\t\t\t\t\t'.+\\\\n', // Header Row\n\t\t\t\t\t\t'[ ]{0,3}',\n\t\t\t\t\t\t'[|][ ]*[-:]+[-| :]*\\\\n', // Separator\n\t\t\t\t\t\t'(?:[ \\t]*[|].*\\\\n?)*', // Table rows\n\t\t\t\t\t\t'$'\n\t\t\t\t\t].join(''),\n\t\t\t\t\t'gm'\n\t\t\t\t),\n\t\t\t\tinside: {}\n\t\t\t}\n\t\t\tgrammar['table alt'] = {\n\t\t\t\tpattern: new RegExp(\n\t\t\t\t\t[\n\t\t\t\t\t\t'^',\n\t\t\t\t\t\t'[ ]{0,3}',\n\t\t\t\t\t\t'\\\\S.*[|].*\\\\n', // Header Row\n\t\t\t\t\t\t'[ ]{0,3}',\n\t\t\t\t\t\t'[-:]+[ ]*[|][-| :]*\\\\n', // Separator\n\t\t\t\t\t\t'(?:.*[|].*\\\\n?)*', // Table rows\n\t\t\t\t\t\t'$' // Stop at final newline\n\t\t\t\t\t].join(''),\n\t\t\t\t\t'gm'\n\t\t\t\t),\n\t\t\t\tinside: {}\n\t\t\t}\n\t\t}\n\t\tif (options.deflists) {\n\t\t\tgrammar.deflist = {\n\t\t\t\tpattern: new RegExp(\n\t\t\t\t\t[\n\t\t\t\t\t\t'^ {0,3}\\\\S.*\\\\n', // Description line\n\t\t\t\t\t\t'(?:[ \\\\t]*\\\\n)?', // Optional empty line\n\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t'[ \\\\t]*:[ \\\\t].*\\\\n', // Colon line\n\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t'.*\\\\S.*\\\\n', // Non-empty line\n\t\t\t\t\t\t'|',\n\t\t\t\t\t\t'[ \\\\t]*\\\\n(?! ?\\\\S)', // Or empty line not followed by unindented line\n\t\t\t\t\t\t')',\n\t\t\t\t\t\t')*',\n\t\t\t\t\t\t'(?:[ \\\\t]*\\\\n)*', // Empty lines\n\t\t\t\t\t\t')+',\n\t\t\t\t\t].join(''),\n\t\t\t\t\t'gm'\n\t\t\t\t),\n\t\t\t\tinside: {\n\t\t\t\t\t'deflist-desc': {\n\t\t\t\t\t\tpattern: /( {0,3}\\S.*\\n(?:[ \\t]*\\n)?)[\\s\\S]*/,\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'cl': /^[ \\t]*:[ \\t]/gm,\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t'term': /.+/g,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.fences) {\n\t\t\t\tgrammar.deflist.inside['deflist-desc'].inside['pre gfm'] = {\n\t\t\t\t\tpattern: /^((?: {4}|\\t)+)(`{3}|~{3}).*\\n(?:[\\s\\S]*?)\\n\\1\\2\\s*$/gm,\n\t\t\t\t\tinside: insideFences\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgrammar.hr = {\n\t\t\tpattern: /^ {0,3}([*\\-_] *){3,}$/gm\n\t\t}\n\t\tif (options.footnotes) {\n\t\t\tgrammar.fndef = {\n\t\t\t\tpattern: /^ {0,3}\\[\\^.*?\\]:.*$/gm,\n\t\t\t\tinside: {\n\t\t\t\t\t'ref-id': {\n\t\t\t\t\t\tpattern: /^ {0,3}\\[\\^.*?\\]/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\tcl: /(\\[\\^|\\])/,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.abbrs) {\n\t\t\tgrammar.abbrdef = {\n\t\t\t\tpattern: /^ {0,3}\\*\\[.*?\\]:.*$/gm,\n\t\t\t\tinside: {\n\t\t\t\t\t'abbr-id': {\n\t\t\t\t\t\tpattern: /^ {0,3}\\*\\[.*?\\]/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\tcl: /(\\*\\[|\\])/,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgrammar.linkdef = {\n\t\t\tpattern: /^ {0,3}\\[.*?\\]:.*$/gm,\n\t\t\tinside: {\n\t\t\t\t'link-id': {\n\t\t\t\t\tpattern: /^ {0,3}\\[.*?\\]/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\tcl: /[\\[\\]]/,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\turl: urlPattern\n\t\t\t}\n\t\t}\n\t\tgrammar.p = {\n\t\t\tpattern: /^ {0,3}\\S.*$(\\n.*\\S.*)*/gm,\n\t\t\tinside: {}\n\t\t}\n\t\tif (options.tocs) {\n\t\t\tgrammar.p.inside['cl cl-toc'] = /^[ \\t]*\\[toc\\]$/mi\n\t\t}\n\t\tgrammar.pre = {\n\t\t\tpattern: /(?: {4}|\\t).*\\S.*\\n((?: {4}|\\t).*\\n)*/g\n\t\t}\n\n\t\tvar rest = {}\n\t\trest.code = {\n\t\t\tpattern: /(`+)[\\s\\S]*?\\1/g,\n\t\t\tinside: {\n\t\t\t\t'cl cl-code': /`/\n\t\t\t}\n\t\t}\n\t\tif (options.maths) {\n\t\t\trest['math block'] = {\n\t\t\t\tpattern: /\\\\\\\\\\[[\\s\\S]*?\\\\\\\\\\]/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl cl-bracket-start': /^\\\\\\\\\\[/,\n\t\t\t\t\t'cl cl-bracket-end': /\\\\\\\\\\]$/,\n\t\t\t\t\trest: latex\n\t\t\t\t}\n\t\t\t}\n\t\t\trest['math inline'] = {\n\t\t\t\tpattern: /\\\\\\\\\\([\\s\\S]*?\\\\\\\\\\)/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl cl-bracket-start': /^\\\\\\\\\\(/,\n\t\t\t\t\t'cl cl-bracket-end': /\\\\\\\\\\)$/,\n\t\t\t\t\trest: latex\n\t\t\t\t}\n\t\t\t}\n\t\t\trest['math expr block'] = {\n\t\t\t\tpattern: /(\\$\\$)[\\s\\S]*?\\1/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl cl-bracket-start': /^\\$\\$/,\n\t\t\t\t\t'cl cl-bracket-end': /\\$\\$$/,\n\t\t\t\t\trest: latex\n\t\t\t\t}\n\t\t\t}\n\t\t\trest['math expr inline'] = {\n\t\t\t\tpattern: /\\$(?!\\s)[\\s\\S]*?\\S\\$(?!\\d)/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl cl-bracket-start': /^\\$/,\n\t\t\t\t\t'cl cl-bracket-end': /\\$$/,\n\t\t\t\t\trest: latex\n\t\t\t\t}\n\t\t\t}\n\t\t\trest['latex block'] = {\n\t\t\t\tpattern: /\\\\begin\\{([a-z]*\\*?)\\}[\\s\\S]*?\\\\?\\\\end\\{\\1\\}/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'keyword': /\\\\(begin|end)/,\n\t\t\t\t\trest: latex\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.footnotes) {\n\t\t\trest.inlinefn = {\n\t\t\t\tpattern: /\\^\\[.+?\\]/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl': /(\\^\\[|\\])/,\n\t\t\t\t}\n\t\t\t}\n\t\t\trest.fn = {\n\t\t\t\tpattern: /\\[\\^.+?\\]/g,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl': /(\\[\\^|\\])/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trest.img = {\n\t\t\tpattern: /!\\[.*?\\]\\(.+?\\)/g,\n\t\t\tinside: {\n\t\t\t\t'cl cl-title': /['‘][^'’]*['’]|[\"“][^\"”]*[\"”](?=\\)$)/,\n\t\t\t\t'cl cl-src': {\n\t\t\t\t\tpattern: /(\\]\\()[^\\('\" \\t]+(?=[\\)'\" \\t])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trest.link = {\n\t\t\tpattern: /\\[.*?\\]\\(.+?\\)/gm,\n\t\t\tinside: {\n\t\t\t\t'cl cl-underlined-text': {\n\t\t\t\t\tpattern: /(\\[)[^\\]]*/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t},\n\t\t\t\t'cl cl-title': /['‘][^'’]*['’]|[\"“][^\"”]*[\"”](?=\\)$)/,\n\t\t\t}\n\t\t}\n\t\trest.imgref = {\n\t\t\tpattern: /!\\[.*?\\][ \\t]*\\[.*?\\]/g,\n\t\t}\n\t\trest.linkref = {\n\t\t\tpattern: /\\[.*?\\][ \\t]*\\[.*?\\]/g,\n\t\t\tinside: {\n\t\t\t\t'cl cl-underlined-text': {\n\t\t\t\t\tpattern: /^(\\[)[^\\]]*(?=\\][ \\t]*\\[)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trest.comment = markup.comment\n\t\trest.tag = markup.tag\n\t\trest.url = urlPattern\n\t\trest.email = emailPattern\n\t\trest.strong = {\n\t\t\tpattern: /(^|[^\\w*])([_\\*])\\2(?![_\\*])[\\s\\S]*?\\2{2}(?=([^\\w*]|$))/gm,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'cl cl-strong cl-start': /^([_\\*])\\1/,\n\t\t\t\t'cl cl-strong cl-close': /([_\\*])\\1$/\n\t\t\t}\n\t\t}\n\t\trest.em = {\n\t\t\tpattern: /(^|[^\\w*])([_\\*])(?![_\\*])[\\s\\S]*?\\2(?=([^\\w*]|$))/gm,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'cl cl-em cl-start': /^[_\\*]/,\n\t\t\t\t'cl cl-em cl-close': /[_\\*]$/\n\t\t\t}\n\t\t}\n\t\tif (options.dels) {\n\t\t\trest.del = {\n\t\t\t\tpattern: /(^|[^\\w*])(~~)[\\s\\S]*?\\2(?=([^\\w*]|$))/gm,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl': /~~/,\n\t\t\t\t\t'cl-del-text': /[^~]+/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.subs) {\n\t\t\trest.sub = {\n\t\t\t\tpattern: /(~)(?=\\S)(.*?\\S)\\1/gm,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl': /~/,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.sups) {\n\t\t\trest.sup = {\n\t\t\t\tpattern: /(\\^)(?=\\S)(.*?\\S)\\1/gm,\n\t\t\t\tinside: {\n\t\t\t\t\t'cl': /\\^/,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trest.entity = markup.entity\n\n\t\tfor (var c = 6; c >= 1; c--) {\n\t\t\tgrammar['h' + c].inside.rest = rest\n\t\t}\n\t\tgrammar['h1 alt'].inside.rest = rest\n\t\tgrammar['h2 alt'].inside.rest = rest\n\t\tif (options.tables) {\n\t\t\tgrammar.table.inside.rest = rest\n\t\t\tgrammar['table alt'].inside.rest = rest\n\t\t}\n\t\tgrammar.p.inside.rest = rest\n\t\tgrammar.blockquote.inside.rest = rest\n\t\tgrammar.li.inside.rest = rest\n\t\tif (options.footnotes) {\n\t\t\tgrammar.fndef.inside.rest = rest\n\t\t}\n\t\tif (options.deflists) {\n\t\t\tgrammar.deflist.inside['deflist-desc'].inside.rest = rest\n\t\t}\n\n\t\tvar restLight = {\n\t\t\tcode: rest.code,\n\t\t\tinlinefn: rest.inlinefn,\n\t\t\tfn: rest.fn,\n\t\t\tlink: rest.link,\n\t\t\tlinkref: rest.linkref\n\t\t}\n\t\trest.strong.inside.rest = restLight\n\t\trest.em.inside.rest = restLight\n\t\tif (options.dels) {\n\t\t\trest.del.inside.rest = restLight\n\t\t}\n\n\t\tvar inside = {\n\t\t\tcode: rest.code,\n\t\t\tcomment: rest.comment,\n\t\t\ttag: rest.tag,\n\t\t\tstrong: rest.strong,\n\t\t\tem: rest.em,\n\t\t\tdel: rest.del,\n\t\t\tsub: rest.sub,\n\t\t\tsup: rest.sup,\n\t\t\tentity: markup.entity\n\t\t}\n\t\trest.link.inside['cl cl-underlined-text'].inside = inside\n\t\trest.linkref.inside['cl cl-underlined-text'].inside = inside\n\n\t\treturn grammar\n\t}\n})()\n","self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t? self // if in worker\n\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function(){\n\n// Private helper vars\nvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\nvar _ = self.Prism = {\n\tutil: {\n\t\tencode: function (tokens) {\n\t\t\tif (tokens instanceof Token) {\n\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t} else {\n\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t}\n\t\t},\n\n\t\ttype: function (o) {\n\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t},\n\n\t\t// Deep clone a language definition (e.g. to extend it)\n\t\tclone: function (o) {\n\t\t\tvar type = _.util.type(o);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Object':\n\t\t\t\t\tvar clone = {};\n\n\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\treturn o.map(function(v) { return _.util.clone(v); });\n\t\t\t}\n\n\t\t\treturn o;\n\t\t}\n\t},\n\n\tlanguages: {\n\t\textend: function (id, redef) {\n\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\tfor (var key in redef) {\n\t\t\t\tlang[key] = redef[key];\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t},\n\n\t\t/**\n\t\t * Insert a token before another token in a language literal\n\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t * @param inside The key (or language id) of the parent\n\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t * @param insert Object with the key/value pairs to insert\n\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t */\n\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\troot = root || _.languages;\n\t\t\tvar grammar = root[inside];\n\t\t\t\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tinsert = arguments[1];\n\t\t\t\t\n\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn grammar;\n\t\t\t}\n\t\t\t\n\t\t\tvar ret = {};\n\n\t\t\tfor (var token in grammar) {\n\n\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\tif (token == before) {\n\n\t\t\t\t\t\tfor (var newToken in insert) {\n\n\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Update references in other language definitions\n\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\tthis[key] = ret;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn root[inside] = ret;\n\t\t},\n\n\t\t// Traverse a language definition with Depth First Search\n\t\tDFS: function(o, callback, type) {\n\t\t\tfor (var i in o) {\n\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\tif (_.util.type(o[i]) === 'Object') {\n\t\t\t\t\t\t_.languages.DFS(o[i], callback);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_.util.type(o[i]) === 'Array') {\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\thighlightAll: function(async, callback) {\n\t\tvar elements = document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');\n\n\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t_.highlightElement(element, async === true, callback);\n\t\t}\n\t},\n\n\thighlightElement: function(element, async, callback) {\n\t\t// Find language\n\t\tvar language, grammar, parent = element;\n\n\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\tif (parent) {\n\t\t\tlanguage = (parent.className.match(lang) || [,''])[1];\n\t\t\tgrammar = _.languages[language];\n\t\t}\n\n\t\tif (!grammar) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set language on the element, if not present\n\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t// Set language on the parent, for styling\n\t\tparent = element.parentNode;\n\n\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t}\n\n\t\tvar code = element.textContent;\n\n\t\tif(!code) {\n\t\t\treturn;\n\t\t}\n\n\t\tcode = code.replace(/^(?:\\r?\\n|\\r)/,'');\n\n\t\tvar env = {\n\t\t\telement: element,\n\t\t\tlanguage: language,\n\t\t\tgrammar: grammar,\n\t\t\tcode: code\n\t\t};\n\n\t\t_.hooks.run('before-highlight', env);\n\n\t\tif (async && self.Worker) {\n\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\tworker.onmessage = function(evt) {\n\t\t\t\tenv.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t};\n\n\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\tlanguage: env.language,\n\t\t\t\tcode: env.code\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\tcallback && callback.call(element);\n\n\t\t\t_.hooks.run('after-highlight', env);\n\t\t}\n\t},\n\n\thighlight: function (text, grammar, language) {\n\t\tvar tokens = _.tokenize(text, grammar);\n\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t},\n\n\ttokenize: function(text, grammar, language) {\n\t\tvar Token = _.Token;\n\n\t\tvar strarr = [text];\n\n\t\tvar rest = grammar.rest;\n\n\t\tif (rest) {\n\t\t\tfor (var token in rest) {\n\t\t\t\tgrammar[token] = rest[token];\n\t\t\t}\n\n\t\t\tdelete grammar.rest;\n\t\t}\n\n\t\ttokenloop: for (var token in grammar) {\n\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\talias = pattern.alias;\n\n\t\t\t\tpattern = pattern.pattern || pattern;\n\n\t\t\t\tfor (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\n\n\t\t\t\t\tvar str = strarr[i];\n\n\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpattern.lastIndex = 0;\n\n\t\t\t\t\tvar match = pattern.exec(str);\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index - 1 + lookbehindLength,\n\t\t\t\t\t\t\tmatch = match[0].slice(lookbehindLength),\n\t\t\t\t\t\t\tlen = match.length,\n\t\t\t\t\t\t\tto = from + len,\n\t\t\t\t\t\t\tbefore = str.slice(0, from + 1),\n\t\t\t\t\t\t\tafter = str.slice(to + 1);\n\n\t\t\t\t\t\tvar args = [i, 1];\n\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);\n\n\t\t\t\t\t\targs.push(wrapped);\n\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn strarr;\n\t},\n\n\thooks: {\n\t\tall: {},\n\n\t\tadd: function (name, callback) {\n\t\t\tvar hooks = _.hooks.all;\n\n\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\thooks[name].push(callback);\n\t\t},\n\n\t\trun: function (name, env) {\n\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\tcallback(env);\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar Token = _.Token = function(type, content, alias) {\n\tthis.type = type;\n\tthis.content = content;\n\tthis.alias = alias;\n};\n\nToken.stringify = function(o, language, parent) {\n\tif (typeof o == 'string') {\n\t\treturn o;\n\t}\n\n\tif (_.util.type(o) === 'Array') {\n\t\treturn o.map(function(element) {\n\t\t\treturn Token.stringify(element, language, o);\n\t\t}).join('');\n\t}\n\n\tvar env = {\n\t\ttype: o.type,\n\t\tcontent: Token.stringify(o.content, language, parent),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage: language,\n\t\tparent: parent\n\t};\n\n\tif (env.type == 'comment') {\n\t\tenv.attributes['spellcheck'] = 'true';\n\t}\n\n\tif (o.alias) {\n\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\tArray.prototype.push.apply(env.classes, aliases);\n\t}\n\n\t_.hooks.run('wrap', env);\n\n\tvar attributes = '';\n\n\tfor (var name in env.attributes) {\n\t\tattributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n\t}\n\n\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\n};\n\nif (!self.document) {\n\tif (!self.addEventListener) {\n\t\t// in Node.js\n\t\treturn self.Prism;\n\t}\n \t// In worker\n\tself.addEventListener('message', function(evt) {\n\t\tvar message = JSON.parse(evt.data),\n\t\t    lang = message.language,\n\t\t    code = message.code;\n\n\t\tself.postMessage(JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang]))));\n\t\tself.close();\n\t}, false);\n\n\treturn self.Prism;\n}\n\n// Get current script and highlight\nvar script = document.getElementsByTagName('script');\n\nscript = script[script.length - 1];\n\nif (script) {\n\t_.filename = script.src;\n\n\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t}\n}\n\nreturn self.Prism;\n\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n","Prism.languages.markup = {\n\t'comment': /<!--[\\w\\W]*?-->/,\n\t'prolog': /<\\?.+?\\?>/,\n\t'doctype': /<!DOCTYPE.+?>/,\n\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t'tag': {\n\t\tpattern: /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[\\w:-]+/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[\\w-]+?:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /=|>|\"/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[\\w:-]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[\\w-]+?:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n","Prism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/,\n\t'class-name': {\n\t\tpattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t}\n\t},\n\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'function': {\n\t\tpattern: /[a-z0-9_]+\\(/i,\n\t\tinside: {\n\t\t\tpunctuation: /\\(/\n\t\t}\n\t},\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t'operator': /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%/,\n\t'ignore': /&(lt|gt|amp);/i,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n","Prism.languages.javascript = Prism.languages.extend('clike', {\n\t'keyword': /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|-?Infinity)\\b/,\n\t'function': /(?!\\d)[a-z0-9_$]+(?=\\()/i\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'script': {\n\t\t\tpattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/i,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /<script[\\w\\W]*?>|<\\/script>/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.javascript\n\t\t\t},\n\t\t\talias: 'language-javascript'\n\t\t}\n\t});\n}\n","Prism.languages.css = {\n\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\tinside: {\n\t\t\t'punctuation': /[;:]/\n\t\t}\n\t},\n\t'url': /url\\((?:([\"'])(\\\\\\n|\\\\?.)*?\\1|.*?)\\)/i,\n\t'selector': /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/,\n\t'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/,\n\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t'important': /\\B!important\\b/i,\n\t'punctuation': /[\\{\\};:]/,\n\t'function': /[-a-z0-9]+(?=\\()/i\n};\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'style': {\n\t\t\tpattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/i,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /<style[\\w\\W]*?>|<\\/style>/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.css\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t'style-attr': {\n\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\tinside: {\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t}, Prism.languages.markup.tag);\n}","/* TODO\n\tFix XML highlighting\n */\n\nPrism.languages.actionscript = Prism.languages.extend('javascript',  {\n\t'keyword': /\\b(?:as|break|case|catch|class|const|default|delete|do|else|extends|finally|for|function|if|implements|import|in|instanceof|interface|internal|is|native|new|null|package|private|protected|public|return|super|switch|this|throw|try|typeof|use|var|void|while|with|dynamic|each|final|get|include|namespace|native|override|set|static)\\b/,\n\t'operator': /(?:[+\\-*\\/%^]|&&?|\\|\\|?|<<?|>>?>?|[!=]=)=?|[=~?@]/\n});\nPrism.languages.actionscript['class-name'].alias = 'function';\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('actionscript', 'operator', {\n\t\t'xml': {\n\t\t\tpattern: /(^|[^.])<[\\s\\S]*>(?=\\s*($|[\\r\\n,.;\\]})<]))/,\n\t\t\tinside: {\n\t\t\t\trest: Prism.languages.markup\n\t\t\t}\n\t\t}\n\t});\n}","Prism.languages.apacheconf = {\n\t'comment': /#.*/,\n\t'directive-inline': {\n\t\tpattern: /^\\s*\\b(AcceptFilter|AcceptPathInfo|AccessFileName|Action|AddAlt|AddAltByEncoding|AddAltByType|AddCharset|AddDefaultCharset|AddDescription|AddEncoding|AddHandler|AddIcon|AddIconByEncoding|AddIconByType|AddInputFilter|AddLanguage|AddModuleInfo|AddOutputFilter|AddOutputFilterByType|AddType|Alias|AliasMatch|Allow|AllowCONNECT|AllowEncodedSlashes|AllowMethods|AllowOverride|AllowOverrideList|Anonymous|Anonymous_LogEmail|Anonymous_MustGiveEmail|Anonymous_NoUserID|Anonymous_VerifyEmail|AsyncRequestWorkerFactor|AuthBasicAuthoritative|AuthBasicFake|AuthBasicProvider|AuthBasicUseDigestAlgorithm|AuthDBDUserPWQuery|AuthDBDUserRealmQuery|AuthDBMGroupFile|AuthDBMType|AuthDBMUserFile|AuthDigestAlgorithm|AuthDigestDomain|AuthDigestNonceLifetime|AuthDigestProvider|AuthDigestQop|AuthDigestShmemSize|AuthFormAuthoritative|AuthFormBody|AuthFormDisableNoStore|AuthFormFakeBasicAuth|AuthFormLocation|AuthFormLoginRequiredLocation|AuthFormLoginSuccessLocation|AuthFormLogoutLocation|AuthFormMethod|AuthFormMimetype|AuthFormPassword|AuthFormProvider|AuthFormSitePassphrase|AuthFormSize|AuthFormUsername|AuthGroupFile|AuthLDAPAuthorizePrefix|AuthLDAPBindAuthoritative|AuthLDAPBindDN|AuthLDAPBindPassword|AuthLDAPCharsetConfig|AuthLDAPCompareAsUser|AuthLDAPCompareDNOnServer|AuthLDAPDereferenceAliases|AuthLDAPGroupAttribute|AuthLDAPGroupAttributeIsDN|AuthLDAPInitialBindAsUser|AuthLDAPInitialBindPattern|AuthLDAPMaxSubGroupDepth|AuthLDAPRemoteUserAttribute|AuthLDAPRemoteUserIsDN|AuthLDAPSearchAsUser|AuthLDAPSubGroupAttribute|AuthLDAPSubGroupClass|AuthLDAPUrl|AuthMerging|AuthName|AuthnCacheContext|AuthnCacheEnable|AuthnCacheProvideFor|AuthnCacheSOCache|AuthnCacheTimeout|AuthnzFcgiCheckAuthnProvider|AuthnzFcgiDefineProvider|AuthType|AuthUserFile|AuthzDBDLoginToReferer|AuthzDBDQuery|AuthzDBDRedirectQuery|AuthzDBMType|AuthzSendForbiddenOnFailure|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|CacheDefaultExpire|CacheDetailHeader|CacheDirLength|CacheDirLevels|CacheDisable|CacheEnable|CacheFile|CacheHeader|CacheIgnoreCacheControl|CacheIgnoreHeaders|CacheIgnoreNoLastMod|CacheIgnoreQueryString|CacheIgnoreURLSessionIdentifiers|CacheKeyBaseURL|CacheLastModifiedFactor|CacheLock|CacheLockMaxAge|CacheLockPath|CacheMaxExpire|CacheMaxFileSize|CacheMinExpire|CacheMinFileSize|CacheNegotiatedDocs|CacheQuickHandler|CacheReadSize|CacheReadTime|CacheRoot|CacheSocache|CacheSocacheMaxSize|CacheSocacheMaxTime|CacheSocacheMinTime|CacheSocacheReadSize|CacheSocacheReadTime|CacheStaleOnError|CacheStoreExpired|CacheStoreNoStore|CacheStorePrivate|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|DeflateBufferSize|DeflateCompressionLevel|DeflateFilterNote|DeflateInflateLimitRequestBody|DeflateInflateRatioBurst|DeflateInflateRatioLimit|DeflateMemLevel|DeflateWindowSize|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|HeartbeatAddress|HeartbeatListen|HeartbeatMaxServers|HeartbeatStorage|HeartbeatStorage|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|IndexHeadInsert|IndexIgnore|IndexIgnoreReset|IndexOptions|IndexOrderDefault|IndexStyleSheet|InputSed|ISAPIAppendLogToErrors|ISAPIAppendLogToQuery|ISAPICacheFile|ISAPIFakeAsync|ISAPILogNotSupported|ISAPIReadAheadBuffer|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAPCacheEntries|LDAPCacheTTL|LDAPConnectionPoolTTL|LDAPConnectionTimeout|LDAPLibraryDebug|LDAPOpCacheEntries|LDAPOpCacheTTL|LDAPReferralHopLimit|LDAPReferrals|LDAPRetries|LDAPRetryDelay|LDAPSharedCacheFile|LDAPSharedCacheSize|LDAPTimeout|LDAPTrustedClientCert|LDAPTrustedGlobalCert|LDAPTrustedMode|LDAPVerifyServerCert|LimitInternalRecursion|LimitRequestBody|LimitRequestFields|LimitRequestFieldSize|LimitRequestLine|LimitXMLRequestBody|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|LuaHookAccessChecker|LuaHookAuthChecker|LuaHookCheckUserID|LuaHookFixups|LuaHookInsertFilter|LuaHookLog|LuaHookMapToStorage|LuaHookTranslateName|LuaHookTypeChecker|LuaInherit|LuaInputFilter|LuaMapHandler|LuaOutputFilter|LuaPackageCPath|LuaPackagePath|LuaQuickHandler|LuaRoot|LuaScope|MaxConnectionsPerChild|MaxKeepAliveRequests|MaxMemFree|MaxRangeOverlaps|MaxRangeReversals|MaxRanges|MaxRequestWorkers|MaxSpareServers|MaxSpareThreads|MaxThreads|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|ProxyAddHeaders|ProxyBadHeader|ProxyBlock|ProxyDomain|ProxyErrorOverride|ProxyExpressDBMFile|ProxyExpressDBMType|ProxyExpressEnable|ProxyFtpDirCharset|ProxyFtpEscapeWildcards|ProxyFtpListOnWildcard|ProxyHTMLBufSize|ProxyHTMLCharsetOut|ProxyHTMLDocType|ProxyHTMLEnable|ProxyHTMLEvents|ProxyHTMLExtended|ProxyHTMLFixups|ProxyHTMLInterp|ProxyHTMLLinks|ProxyHTMLMeta|ProxyHTMLStripComments|ProxyHTMLURLMap|ProxyIOBufferSize|ProxyMaxForwards|ProxyPass|ProxyPassInherit|ProxyPassInterpolateEnv|ProxyPassMatch|ProxyPassReverse|ProxyPassReverseCookieDomain|ProxyPassReverseCookiePath|ProxyPreserveHost|ProxyReceiveBufferSize|ProxyRemote|ProxyRemoteMatch|ProxyRequests|ProxySCGIInternalRedirect|ProxySCGISendfile|ProxySet|ProxySourceAddress|ProxyStatus|ProxyTimeout|ProxyVia|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIPHeader|RemoteIPInternalProxy|RemoteIPInternalProxyList|RemoteIPProxiesHeader|RemoteIPTrustedProxy|RemoteIPTrustedProxyList|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|RewriteBase|RewriteCond|RewriteEngine|RewriteMap|RewriteOptions|RewriteRule|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script|ScriptAlias|ScriptAliasMatch|ScriptInterpreterSource|ScriptLog|ScriptLogBuffer|ScriptLogLength|ScriptSock|SecureListen|SeeRequestTail|SendBufferSize|ServerAdmin|ServerAlias|ServerLimit|ServerName|ServerPath|ServerRoot|ServerSignature|ServerTokens|Session|SessionCookieName|SessionCookieName2|SessionCookieRemove|SessionCryptoCipher|SessionCryptoDriver|SessionCryptoPassphrase|SessionCryptoPassphraseFile|SessionDBDCookieName|SessionDBDCookieName2|SessionDBDCookieRemove|SessionDBDDeleteLabel|SessionDBDInsertLabel|SessionDBDPerUser|SessionDBDSelectLabel|SessionDBDUpdateLabel|SessionEnv|SessionExclude|SessionHeader|SessionInclude|SessionMaxAge|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSLCACertificateFile|SSLCACertificatePath|SSLCADNRequestFile|SSLCADNRequestPath|SSLCARevocationCheck|SSLCARevocationFile|SSLCARevocationPath|SSLCertificateChainFile|SSLCertificateFile|SSLCertificateKeyFile|SSLCipherSuite|SSLCompression|SSLCryptoDevice|SSLEngine|SSLFIPS|SSLHonorCipherOrder|SSLInsecureRenegotiation|SSLOCSPDefaultResponder|SSLOCSPEnable|SSLOCSPOverrideResponder|SSLOCSPResponderTimeout|SSLOCSPResponseMaxAge|SSLOCSPResponseTimeSkew|SSLOCSPUseRequestNonce|SSLOpenSSLConfCmd|SSLOptions|SSLPassPhraseDialog|SSLProtocol|SSLProxyCACertificateFile|SSLProxyCACertificatePath|SSLProxyCARevocationCheck|SSLProxyCARevocationFile|SSLProxyCARevocationPath|SSLProxyCheckPeerCN|SSLProxyCheckPeerExpire|SSLProxyCheckPeerName|SSLProxyCipherSuite|SSLProxyEngine|SSLProxyMachineCertificateChainFile|SSLProxyMachineCertificateFile|SSLProxyMachineCertificatePath|SSLProxyProtocol|SSLProxyVerify|SSLProxyVerifyDepth|SSLRandomSeed|SSLRenegBufferSize|SSLRequire|SSLRequireSSL|SSLSessionCache|SSLSessionCacheTimeout|SSLSessionTicketKeyFile|SSLSRPUnknownUserSeed|SSLSRPVerifierFile|SSLStaplingCache|SSLStaplingErrorCacheTimeout|SSLStaplingFakeTryLater|SSLStaplingForceURL|SSLStaplingResponderTimeout|SSLStaplingResponseMaxAge|SSLStaplingResponseTimeSkew|SSLStaplingReturnResponderErrors|SSLStaplingStandardCacheTimeout|SSLStrictSNIVHostCheck|SSLUserName|SSLUseStapling|SSLVerifyClient|SSLVerifyDepth|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|VirtualDocumentRoot|VirtualDocumentRootIP|VirtualScriptAlias|VirtualScriptAliasIP|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\\b/mi,\n\t\talias: 'property'\n\t},\n\t'directive-block': {\n\t\tpattern: /<\\/?\\b(AuthnProviderAlias|AuthzProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|RequireAll|RequireAny|RequireNone|VirtualHost)\\b *.*>/i,\n\t\tinside: {\n\t\t\t'directive-block': {\n\t\t\t\tpattern: /^<\\/?\\w+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/\n\t\t\t\t},\n\t\t\t\talias: 'tag'\n\t\t\t},\n\t\t\t'directive-block-parameter': {\n\t\t\t\tpattern: /.*[^>]/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /:/,\n\t\t\t\t\t'string': {\n\t\t\t\t\t\tpattern: /(\"|').*\\1/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'variable': /(\\$|%)\\{?(\\w\\.?(\\+|\\-|:)?)+\\}?/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\talias: 'attr-value'\n\t\t\t},\n\t\t\t'punctuation': />/\n\t\t},\n\t\talias: 'tag'\n\t},\n\t'directive-flags': {\n\t\tpattern: /\\[(\\w,?)+\\]/,\n\t\talias: 'keyword'\n\t},\n\t'string': {\n\t\tpattern: /(\"|').*\\1/,\n\t\tinside: {\n\t\t\t'variable': /(\\$|%)\\{?(\\w\\.?(\\+|\\-|:)?)+\\}?/\n\t\t}\n\t},\n\t'variable': /(\\$|%)\\{?(\\w\\.?(\\+|\\-|:)?)+\\}?/,\n\t'regex': /\\^?.*\\$|\\^.*\\$?/\n};\n","/* TODO\n\tAdd support for nested block comments...\n*/\n\nPrism.languages.applescript = {\n\t'comment': [\n\t\t/\\(\\*[\\w\\W]*?\\*\\)/,\n\t\t/--.+/,\n\t\t/#.+/\n\t],\n\t'string': /\"(?:\\\\?.)*?\"/,\n\t'operator': [\n\t\t/[&=≠≤≥*+\\-\\/÷^]|[<>]=?/,\n\t\t/\\b(?:(?:start|begin|end)s? with|(?:(?:does not|doesn't) contain|contains?)|(?:is|isn't|is not) (?:in|contained by)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:(?:does not|doesn't) come|comes) (?:before|after)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equals|equal to|isn't|is not)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|or|div|mod|as|not))\\b/\n\t],\n\t'keyword': /\\b(?:about|above|after|against|and|apart from|around|as|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|contain|contains|continue|copy|div|does|eighth|else|end|equal|equals|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|mod|my|ninth|not|of|on|onto|or|out of|over|prop|property|put|ref|reference|repeat|return|returning|script|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\\b/,\n\t'class': {\n\t\tpattern: /\\b(?:alias|application|boolean|class|constant|date|file|integer|list|number|POSIX file|real|record|reference|RGB color|script|text|centimetres|centimeters|feet|inches|kilometres|kilometers|metres|meters|miles|yards|square feet|square kilometres|square kilometers|square metres|square meters|square miles|square yards|cubic centimetres|cubic centimeters|cubic feet|cubic inches|cubic metres|cubic meters|cubic yards|gallons|litres|liters|quarts|grams|kilograms|ounces|pounds|degrees Celsius|degrees Fahrenheit|degrees Kelvin)\\b/,\n\t\talias: 'builtin'\n\t},\n\t'number': /\\b-?\\d*\\.?\\d+([Ee]-?\\d+)?\\b/,\n\t'punctuation': /[{}():,¬«»《》]/\n};","Prism.languages.aspnet = Prism.languages.extend('markup', {\n\t'page-directive tag': {\n\t\tpattern: /<%\\s*@.*%>/i,\n\t\tinside: {\n\t\t\t'page-directive tag': /<%\\s*@\\s*(?:Assembly|Control|Implements|Import|Master|MasterType|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,\n\t\t\trest: Prism.languages.markup.tag.inside\n\t\t}\n\t},\n\t'directive tag': {\n\t\tpattern: /<%.*%>/i,\n\t\tinside: {\n\t\t\t'directive tag': /<%\\s*?[$=%#:]{0,2}|%>/i,\n\t\t\trest: Prism.languages.csharp\n\t\t}\n\t}\n});\n\n// match directives of attribute value foo=\"<% Bar %>\"\nPrism.languages.insertBefore('inside', 'punctuation', {\n\t'directive tag': Prism.languages.aspnet['directive tag']\n}, Prism.languages.aspnet.tag.inside[\"attr-value\"]);\n\nPrism.languages.insertBefore('aspnet', 'comment', {\n\t'asp comment': /<%--[\\w\\W]*?--%>/\n});\n\n// script runat=\"server\" contains csharp, not javascript\nPrism.languages.insertBefore('aspnet', Prism.languages.javascript ? 'script' : 'tag', {\n\t'asp script': {\n\t\tpattern: /<script(?=.*runat=['\"]?server['\"]?)[\\w\\W]*?>[\\w\\W]*?<\\/script>/i,\n\t\tinside: {\n\t\t\ttag: {\n\t\t\t\tpattern: /<\\/?script\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|\\w+))?\\s*)*\\/?>/i,\n\t\t\t\tinside: Prism.languages.aspnet.tag.inside\n\t\t\t},\n\t\t\trest: Prism.languages.csharp || {}\n\t\t}\n\t}\n});\n\n// Hacks to fix eager tag matching finishing too early: <script src=\"<% Foo.Bar %>\"> => <script src=\"<% Foo.Bar %>\nif ( Prism.languages.aspnet.style ) {\n\tPrism.languages.aspnet.style.inside.tag.pattern = /<\\/?style\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|\\w+))?\\s*)*\\/?>/i;\n\tPrism.languages.aspnet.style.inside.tag.inside = Prism.languages.aspnet.tag.inside;\n}\nif ( Prism.languages.aspnet.script ) {\n\tPrism.languages.aspnet.script.inside.tag.pattern = Prism.languages.aspnet['asp script'].inside.tag.pattern;\n\tPrism.languages.aspnet.script.inside.tag.inside = Prism.languages.aspnet.tag.inside;\n}","// NOTES - follows first-first highlight method, block is locked after highlight, different from SyntaxHl\r\nPrism.languages.autohotkey= {\r\n\t'comment': {\r\n\t\tpattern: /(^[^\";\\n]*(\"[^\"\\n]*?\"[^\"\\n]*?)*)(;.*$|^\\s*\\/\\*[\\s\\S]*\\n\\*\\/)/m,\r\n\t\tlookbehind: true\r\n\t},\r\n\t'string': /\"(([^\"\\n\\r]|\"\")*)\"/m,\r\n\t'function': /[^\\(\\); \\t,\\n\\+\\*\\-=\\?>:\\\\\\/<&%\\[\\]]+?(?=\\()/m,  //function - don't use .*\\) in the end bcoz string locks it\r\n\t'tag': /^[ \\t]*[^\\s:]+?(?=:[^:])/m,  //labels\r\n\t'variable': /%\\w+%/,\r\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\r\n\t'operator': /[\\+\\-\\*\\\\\\/:=\\?&\\|<>]/,\r\n\t'punctuation': /[\\{}[\\]\\(\\):]/,\r\n\t'boolean': /\\b(true|false)\\b/,\r\n\r\n\t'selector': /\\b(AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\\b/i,\r\n\r\n\t'constant': /\\b(a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_formatfloat|a_formatinteger|a_gui|a_guievent|a_guicontrol|a_guicontrolevent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|programfiles|a_programfiles|a_programs|a_programscommon|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel)\\b/i,\r\n\r\n\t'builtin': /\\b(abs|acos|asc|asin|atan|ceil|chr|class|cos|dllcall|exp|fileexist|Fileopen|floor|getkeystate|il_add|il_create|il_destroy|instr|substr|isfunc|islabel|IsObject|ln|log|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|onmessage|numget|numput|registercallback|regexmatch|regexreplace|round|sin|tan|sqrt|strlen|sb_seticon|sb_setparts|sb_settext|strsplit|tv_add|tv_delete|tv_getchild|tv_getcount|tv_getnext|tv_get|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__New|__Call|__Get|__Set)\\b/i,\r\n\r\n\t'symbol': /\\b(alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|control|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pause|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\\b/i,\r\n\r\n\t'important': /#\\b(AllowSameLineComments|ClipboardTimeout|CommentFlag|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InstallKeybdHook|InstallMouseHook|KeyHistory|LTrim|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|WinActivateForce)\\b/i,\r\n\r\n\t'keyword': /\\b(Abort|AboveNormal|Add|ahk_class|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Checkbox|Checked|CheckedGray|Choose|ChooseString|Click|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|Delete|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Exp|Expand|ExStyle|FileSystem|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|Ln|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Region|Relative|Rename|Report|Resize|Restore|Retry|RGB|Right|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab|Tab2|TabStop|Text|Theme|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|TryAgain|Type|UnCheck|underline|Unicode|Unlock|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\\b/i\r\n};","Prism.languages.bash = Prism.languages.extend('clike', {\n\t'comment': {\n\t\tpattern: /(^|[^\"{\\\\])(#.*?(\\r?\\n|$))/,\n\t\tlookbehind: true\n\t},\n\t'string': {\n\t\t//allow multiline string\n\t\tpattern: /(\"|')(\\\\?[\\s\\S])*?\\1/,\n\t\tinside: {\n\t\t\t//'property' class reused for bash variables\n\t\t\t'property': /\\$([a-zA-Z0-9_#\\?\\-\\*!@]+|\\{[^\\}]+\\})/\n\t\t}\n\t},\n\t// Redefined to prevent highlighting of numbers in filenames\n\t'number': {\n\t\tpattern: /([^\\w\\.])-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t\tlookbehind: true\n\t},\n\t// Originally based on http://ss64.com/bash/\n\t'function': /\\b(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|declare|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|echo|egrep|eject|enable|env|ethtool|eval|exec|exit|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|select|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|until|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)\\b/,\n\t'keyword': /\\b(if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)\\b/\n});\n\nPrism.languages.insertBefore('bash', 'keyword', {\n\t//'property' class reused for bash variables\n\t'property': /\\$([a-zA-Z0-9_#\\?\\-\\*!@]+|\\{[^}]+\\})/\n});\nPrism.languages.insertBefore('bash', 'comment', {\n\t//shebang must be before comment, 'important' class from css reused\n\t'important': /(^#!\\s*\\/bin\\/bash)|(^#!\\s*\\/bin\\/sh)/\n});\n","Prism.languages.c = Prism.languages.extend('clike', {\n\t// allow for c multiline strings\n\t'string': /(\"|')([^\\n\\\\\\1]|\\\\.|\\\\\\r*\\n)*?\\1/,\n\t'keyword': /\\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\\b/,\n\t'operator': /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\\->|={1,2}|\\^|~|%|&{1,2}|\\|?\\||\\?|\\*|\\//\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t// property class reused for macro statements\n\t'property': {\n\t\t// allow for multiline macro definitions\n\t\t// spaces after the # character compile fine with gcc\n\t\tpattern: /((^|\\n)\\s*)#\\s*[a-z]+([^\\n\\\\]|\\\\.|\\\\\\r*\\n)*/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t// highlight the path of the include statement as a string\n\t\t\t'string': {\n\t\t\t\tpattern: /(#\\s*include\\s*)(<.+?>|(\"|')(\\\\?.)+?\\3)/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t}\n\t}\n});\n\ndelete Prism.languages.c['class-name'];\ndelete Prism.languages.c['boolean'];","(function(Prism) {\n\n// Ignore comments starting with { to privilege string interpolation highlighting\nvar comment = /#(?!\\{).+/,\n    interpolation = {\n    \tpattern: /#\\{[^}]+\\}/,\n    \talias: 'variable'\n    };\n\nPrism.languages.coffeescript = Prism.languages.extend('javascript', {\n\t'comment': comment,\n\t'string': [\n\n\t\t// Strings are multiline\n\t\t/'(?:\\\\?[\\s\\S])*?'/,\n\n\t\t{\n\t\t\t// Strings are multiline\n\t\t\tpattern: /\"(?:\\\\?[\\s\\S])*?\"/,\n\t\t\tinside: {\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t}\n\t],\n\t'keyword': /\\b(and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n\t'class-member': {\n\t\tpattern: /@(?!\\d)\\w+/,\n\t\talias: 'variable'\n\t}\n});\n\nPrism.languages.insertBefore('coffeescript', 'comment', {\n\t'multiline-comment': {\n\t\tpattern: /###[\\s\\S]+?###/,\n\t\talias: 'comment'\n\t},\n\n\t// Block regexp can contain comments and interpolation\n\t'block-regex': {\n\t\tpattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n\t\talias: 'regex',\n\t\tinside: {\n\t\t\t'comment': comment,\n\t\t\t'interpolation': interpolation\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('coffeescript', 'string', {\n\t'inline-javascript': {\n\t\tpattern: /`(?:\\\\?[\\s\\S])*?`/,\n\t\tinside: {\n\t\t\t'delimiter': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'punctuation'\n\t\t\t},\n\t\t\trest: Prism.languages.javascript\n\t\t}\n\t},\n\n\t// Block strings\n\t'multiline-string': [\n\t\t{\n\t\t\tpattern: /'''[\\s\\S]*?'''/,\n\t\t\talias: 'string'\n\t\t},\n\t\t{\n\t\t\tpattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\tinterpolation: interpolation\n\t\t\t}\n\t\t}\n\t]\n\n});\n\nPrism.languages.insertBefore('coffeescript', 'keyword', {\n\t// Object property\n\t'property': /(?!\\d)\\w+(?=\\s*:(?!:))/\n});\n\n}(Prism));","Prism.languages.cpp = Prism.languages.extend('c', {\n\t'keyword': /\\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|delete\\[\\]|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|new\\[\\]|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'operator': /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\\->|:{1,2}|={1,2}|\\^|~|%|&{1,2}|\\|?\\||\\?|\\*|\\/|\\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/\n});\n\nPrism.languages.insertBefore('cpp', 'keyword', {\n\t'class-name': {\n\t\tpattern: /(class\\s+)[a-z0-9_]+/i,\n\t\tlookbehind: true\n\t}\n});","Prism.languages.csharp = Prism.languages.extend('clike', {\n\t'keyword': /\\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\\b/,\n\t'string': /@?(\"|')(\\\\?.)*?\\1/,\n\t'preprocessor': /^\\s*#.*/m,\n\t'number': /\\b-?(0x[\\da-f]+|\\d*\\.?\\d+)\\b/i\n});\n","Prism.languages.css.selector = {\n\tpattern: /[^\\{\\}\\s][^\\{\\}]*(?=\\s*\\{)/,\n\tinside: {\n\t\t'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n\t\t'pseudo-class': /:[-\\w]+(?:\\(.*\\))?/,\n\t\t'class': /\\.[-:\\.\\w]+/,\n\t\t'id': /#[-:\\.\\w]+/\n\t}\n};\n\nPrism.languages.insertBefore('css', 'function', {\n\t'hexcode': /#[\\da-f]{3,6}/i,\n\t'entity': /\\\\[\\da-f]{1,8}/i,\n\t'number': /[\\d%\\.]+/\n});","Prism.languages.dart = Prism.languages.extend('clike', {\n\t'string': [\n\t\t/r?(\"\"\"|''')[\\s\\S]*?\\1/,\n\t\t/r?(\"|')(\\\\?.)*?\\1/\n\t],\n\t'keyword': [\n\t\t/\\b(?:async|sync|yield)\\*/,\n\t\t/\\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|default|deferred|do|dynamic|else|enum|export|external|extends|factory|final|finally|for|get|if|implements|import|in|library|new|null|operator|part|rethrow|return|set|static|super|switch|this|throw|try|typedef|var|void|while|with|yield)\\b/\n\t],\n\t'operator': /\\bis!|\\b(?:as|is)\\b|\\+\\+|--|&&|\\|\\||<<=?|>>=?|~(?:\\/=?)?|[+\\-*\\/%&^|=!<>]=?|\\?/\n});\n\nPrism.languages.insertBefore('dart','function',{\n\t'metadata': {\n\t\tpattern: /@\\w+/,\n\t\talias: 'symbol'\n\t}\n});","Prism.languages.eiffel = {\n\t'string': [\n\t\t// Single-line string\n\t\t/\"(?:%\\s+%|%\"|.)*?\"/,\n\t\t// Aligned-verbatim-strings\n\t\t/\"([^[]*)\\[[\\s\\S]+?\\]\\1\"/,\n\t\t// Non-aligned-verbatim-strings\n\t\t/\"([^{]*)\\{[\\s\\S]+?\\}\\1\"/\n\t],\n\t// (comments including quoted strings not supported)\n\t'comment': /--.*/,\n\t// normal char | special char | char code\n\t'char': /'(?:%'|.)+?'/,\n\t'keyword': /\\b(?:across|agent|alias|all|and|attached|as|assign|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\\b/i,\n\t'boolean': /\\b(?:True|False)\\b/i,\n\t'number': [\n\t\t// hexa | octal | bin\n\t\t/\\b0[xcb][\\da-f](?:_*[\\da-f])*\\b/i,\n\t\t// Decimal\n\t\t/(?:\\d(?:_*\\d)*)?\\.(?:(?:\\d(?:_*\\d)*)?[eE][+-]?)?\\d(?:_*\\d)*|\\d(?:_*\\d)*\\.?/\n\t],\n\t'punctuation': /:=|<<|>>|\\(\\||\\|\\)|->|\\.(?=\\w)|[{}[\\];(),:?]/,\n\t'operator': /\\\\\\\\|\\|\\.\\.\\||\\.\\.|\\/[~\\/]?|[><\\/]=?|[-+*^=~]/\n};\n","Prism.languages.erlang = {\n\t'comment': /%.+/,\n\t'string': /\"(?:\\\\?.)*?\"/,\n\t'quoted-function': {\n\t\tpattern: /'[^']+'(?=\\()/,\n\t\talias: 'function'\n\t},\n\t'quoted-atom': {\n\t\tpattern: /'[^']+'/,\n\t\talias: 'atom'\n\t},\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'keyword': /\\b(?:fun|when|case|of|end|if|receive|after|try|catch)\\b/,\n\t'number': [\n\t\t/\\$\\\\?./,\n\t\t/\\d+#[a-z0-9]+/i,\n\t\t/(?:\\b|-)\\d*\\.?\\d+([Ee][+-]?\\d+)?\\b/\n\t],\n\t'function': /\\b[a-z][\\w@]*(?=\\()/,\n\t'variable': /(?:\\b|\\?)[A-Z_][\\w@]*/,\n\t'operator': [\n\t\t/[=\\/>:]=|>=|=[:\\/]=|\\+\\+?|--?|[=*\\/!]|\\b(?:bnot|div|rem|band|bor|bxor|bsl|bsr|not|and|or|xor|orelse|andalso)\\b/,\n\t\t{\n\t\t\tpattern: /(^|(?!<).)<(?!<)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|(?!>).)>(?!>)/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'atom': /\\b[a-z][\\w@]*/,\n\t'punctuation': /[()[\\]{}:;,.#|]|<<|>>/\n\n};","Prism.languages.fortran = {\n\t'quoted-number': {\n\t\tpattern: /[BOZ](['\"])[A-F0-9]+\\1/i,\n\t\talias: 'number'\n\t},\n\t'string': {\n\t\tpattern: /(?:\\w+_)?(['\"])(?:\\1\\1|&\\n(?:\\s*!.+\\n)?|(?!\\1).)*(?:\\1|&)/,\n\t\tinside: {\n\t\t\t'comment': /!.*/\n\t\t}\n\t},\n\t'comment': /!.*/,\n\t'boolean': /\\.(?:TRUE|FALSE)\\.(?:_\\w+)?/i,\n\t'number': /(?:\\b|[+-])(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[ED][+-]?\\d+)?(?:_\\w+)?/i,\n\t'keyword': [\n\t\t// Types\n\t\t/\\b(?:INTEGER|REAL|DOUBLE ?PRECISION|COMPLEX|CHARACTER|LOGICAL)\\b/i,\n\t\t// Statements\n\t\t/\\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\\b/i,\n\t\t// END statements\n\t\t/\\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\\b/i,\n\t\t// Others\n\t\t/\\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEWHERE|ELSEIF|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\\b/i\n\t],\n\t'operator': [\n\t\t/\\*\\*|\\/\\/|=>|[=\\/]=|[<>]=?|::|[+\\-*=%]|\\.(?:EQ|NE|LT|LE|GT|GE|NOT|AND|OR|EQV|NEQV)\\.|\\.[A-Z]+\\./i,\n\t\t{\n\t\t\t// Use lookbehind to prevent confusion with (/ /)\n\t\t\tpattern: /(^|(?!\\().)\\/(?!\\))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'punctuation': /\\(\\/|\\/\\)|[(),;:&]/\n};","Prism.languages.fsharp = Prism.languages.extend('clike', {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\(\\*[\\w\\W]*?\\*\\)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': /\\b(abstract|and|as|assert|base|begin|class|default|delegate|do|done|downcast|downto|elif|else|end|exception|extern|false|finally|for|fun|function|global|if|in|inherit|inline|interface|internal|lazy|let|let!|match|member|module|mutable|namespace|new|not|null|of|open|or|override|private|public|rec|return|return!|select|static|struct|then|to|true|try|type|upcast|use|use!|val|void|when|while|with|yield|yield!|asr|land|lor|lsl|lsr|lxor|mod|sig|atomic|break|checked|component|const|constraint|constructor|continue|eager|event|external|fixed|functor|include|method|mixin|object|parallel|process|protected|pure|sealed|tailcall|trait|virtual|volatile)\\b/,\n\t'string': /@?(\"\"\"|\"|')((\\\\|\\n)?.)*?\\1B?/,\n\t'preprocessor': /^\\s*#.*/m,\n\t'number': [\n\t\t/\\b-?0x[\\da-fA-F]+(un|lf|LF)?\\b/,\n\t\t/\\b-?0b[01]+(y|uy)?\\b/,\n\t\t/\\b-?(\\d+\\.|\\d*\\.?\\d+)([fFmM]|[eE][+-]?\\d+)?\\b/,\n\t\t/\\b-?\\d+(y|uy|s|us|l|u|ul|L|UL|I)?\\b/\n\t]\n});","Prism.languages.gherkin = {\n\t'pystring': {\n\t\tpattern: /(\"\"\"|''')[\\s\\S]+?\\1/,\n\t\talias: 'string'\n\t},\n\t'comment': {\n\t\tpattern: /((^|\\n)[ \\t]*)#.*/,\n\t\tlookbehind: true\n\t},\n\t'tag': {\n\t\tpattern: /((^|\\n)[ \\t]*)@.*/,\n\t\tlookbehind: true\n\t},\n\t'feature': {\n\t\tpattern: /((^|\\n)[ \\t]*)(Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|laH|Lastnost|Mak|Mogucnost|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|perbogh|poQbogh malja'|Potrzeba biznesowa|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):([^:]+\\n)*/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'important': {\n\t\t\t\tpattern: /(:)[^\\n]+/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\tkeyword: /[^:\\n]+:/\n\t\t}\n\t},\n\t'scenario': {\n\t\tpattern: /((^|\\n)[ \\t]*)(Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram senaryo|Dyagram Senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|Examples|EXAMPLZ|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|ghantoH|Grundlage|Hannergrond|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut|lut chovnatlh|lutmey|Lýsing Atburðarásar|Lýsing Dæma|Menggariskan Senario|MISHUN|MISHUN SRSLY|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan senaryo|Plan Senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo|Senaryo deskripsyon|Senaryo Deskripsyon|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie|Situasie Uiteensetting|Skenario|Skenario konsep|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa|Swa hwaer swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo\\-ho\\-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\\n]*/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'important': {\n\t\t\t\tpattern: /(:)[^\\n]*/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\tkeyword: /[^:\\n]+:/\n\t\t}\n\t},\n\t'table-body': {\n\t\tpattern: /(\\n[ \\t]*\\|.+\\|[^\\n]*)+/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'outline': {\n\t\t\t\tpattern: /<[^>]+?>/,\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\t'td': {\n\t\t\t\tpattern: /[^|]+/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'punctuation': /\\|/\n\t\t}\n\t},\n\t'table-head': {\n\t\tpattern: /(\\n[ \\t]*\\|.+\\|[^\\n]*)/,\n\t\tinside: {\n\t\t\t'th': {\n\t\t\t\tpattern: /[^|]+/,\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\t'punctuation': /\\|/\n\t\t}\n\t},\n\t'atrule': {\n\t\tpattern: /(\\n[ \\t]+)('ach|'a|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cando|Cand|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|Dato|DEN|Den youse gotta|Dengan|De|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|Entonces|En|Epi|E|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kadar|Kada|Kad|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Majd|Maka|Manawa|Mas|Ma|Menawa|Men|Mutta|Nalikaning|Nalika|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Og|Och|Oletetaan|Onda|Ond|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|qaSDI'|Quando|Quand|Quan|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|ugeholl|Und|Un|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadani|Zadano|Zadan|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa|Þá|Þa þe|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \\t]+)/,\n\t\tlookbehind: true\n\t},\n\t'string': {\n\t\tpattern: /(\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*')/,\n\t\tinside: {\n\t\t\t'outline': {\n\t\t\t\tpattern: /<[^>]+?>/,\n\t\t\t\talias: 'variable'\n\t\t\t}\n\t\t}\n\t},\n\t'outline': {\n\t\tpattern: /<[^>]+?>/,\n\t\talias: 'variable'\n\t}\n};\n","Prism.languages.git = {\n\t/*\n\t * A simple one line comment like in a git status command\n\t * For instance:\n\t * $ git status\n\t * # On branch infinite-scroll\n\t * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n\t * # and have 1 and 2 different commits each, respectively.\n\t * nothing to commit (working directory clean)\n\t */\n\t'comment': /^#.*$/m,\n\n\t/*\n\t * a string (double and simple quote)\n\t */\n\t'string': /(\"|')(\\\\?.)*?\\1/m,\n\n\t/*\n\t * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n\t * For instance:\n\t * $ git add file.txt\n\t */\n\t'command': {\n\t\tpattern: /^.*\\$ git .*$/m,\n\t\tinside: {\n\t\t\t/*\n\t\t\t * A git command can contain a parameter starting by a single or a double dash followed by a string\n\t\t\t * For instance:\n\t\t\t * $ git diff --cached\n\t\t\t * $ git log -p\n\t\t\t */\n\t\t\t'parameter': /\\s(--|-)\\w+/m\n\t\t}\n\t},\n\n\t/*\n\t * Coordinates displayed in a git diff command\n\t * For instance:\n\t * $ git diff\n\t * diff --git file.txt file.txt\n\t * index 6214953..1d54a52 100644\n\t * --- file.txt\n\t * +++ file.txt\n\t * @@ -1 +1,2 @@\n\t * -Here's my tetx file\n\t * +Here's my text file\n\t * +And this is the second line\n\t */\n\t'coord': /^@@.*@@$/m,\n\n\t/*\n\t * Regexp to match the changed lines in a git diff output. Check the example above.\n\t */\n\t'deleted': /^-(?!-).+$/m,\n\t'inserted': /^\\+(?!\\+).+$/m,\n\n\t/*\n\t * Match a \"commit [SHA1]\" line in a git log output.\n\t * For instance:\n\t * $ git log\n\t * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n\t * Author: lgiraudel\n\t * Date:   Mon Feb 17 11:18:34 2014 +0100\n\t *\n\t *     Add of a new line\n\t */\n\t'commit_sha1': /^commit \\w{40}$/m\n};\n","Prism.languages.go = Prism.languages.extend('clike', {\n\t'keyword': /\\b(break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n\t'builtin': /\\b(bool|byte|complex(64|128)|error|float(32|64)|rune|string|u?int(8|16|32|64|)|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(ln)?|real|recover)\\b/,\n\t'boolean': /\\b(_|iota|nil|true|false)\\b/,\n\t'operator': /([(){}\\[\\]]|[*\\/%^!]=?|\\+[=+]?|-[>=-]?|\\|[=|]?|>[=>]?|<(<|[=-])?|==?|&(&|=|^=?)?|\\.(\\.\\.)?|[,;]|:=?)/,\n\t'number': /\\b(-?(0x[a-f\\d]+|(\\d+\\.?\\d*|\\.\\d+)(e[-+]?\\d+)?)i?)\\b/i,\n\t'string': /(\"|'|`)(\\\\?.|\\r|\\n)*?\\1/\n});\ndelete Prism.languages.go['class-name'];\n","Prism.languages.groovy = Prism.languages.extend('clike', {\n\t'keyword': /\\b(as|def|in|abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\\b/,\n\t'string': /(\"\"\"|''')[\\W\\w]*?\\1|(\"|'|\\/)(?:\\\\?.)*?\\2|(\\$\\/)(\\$\\/\\$|[\\W\\w])*?\\/\\$/,\n\t'number': /\\b0b[01_]+\\b|\\b0x[\\da-f_]+(\\.[\\da-f_p\\-]+)?\\b|\\b[\\d_]+(\\.[\\d_]+[e]?[\\d]*)?[glidf]\\b|[\\d_]+(\\.[\\d_]+)?\\b/i,\n\t'operator': {\n\t\tpattern: /(^|[^.])(={0,2}~|\\?\\.|\\*?\\.@|\\.&|\\.{1,2}(?!\\.)|\\.{2}<?(?=\\w)|->|\\?:|[-+]{1,2}|!|<=>|>{1,3}|<{1,2}|={1,2}|&{1,2}|\\|{1,2}|\\?|\\*{1,2}|\\/|\\^|%)/,\n\t\tlookbehind: true\n\t},\n\t'punctuation': /\\.+|[{}[\\];(),:$]/\n});\n\nPrism.languages.insertBefore('groovy', 'string', {\n\t'shebang': {\n\t\tpattern: /#!.+/,\n\t\talias: 'comment'\n\t}\n});\n\nPrism.languages.insertBefore('groovy', 'punctuation', {\n\t'spock-block': /\\b(setup|given|when|then|and|cleanup|expect|where):/\n});\n\nPrism.languages.insertBefore('groovy', 'function', {\n\t'annotation': {\n\t\tpattern: /(^|[^.])@\\w+/,\n\t\tlookbehind: true\n\t}\n});\n\nPrism.hooks.add('wrap', function(env) {\n\tif (env.language === 'groovy' && env.type === 'string') {\n\t\tvar delimiter = env.content[0];\n\n\t\tif (delimiter != \"'\") {\n\t\t\tvar pattern = /([^\\\\])(\\$(\\{.*?\\}|[\\w\\.]+))/;\n\t\t\tif (delimiter === '$') {\n\t\t\t\tpattern = /([^\\$])(\\$(\\{.*?\\}|[\\w\\.]+))/;\n\t\t\t}\n\t\t\tenv.content = Prism.highlight(env.content, {\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: pattern,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: Prism.languages.groovy\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tenv.classes.push(delimiter === '/' ? 'regex' : 'gstring');\n\t\t}\n\t}\n});\n","/* TODO\n\tHandle multiline code after tag\n\t    %foo= some |\n\t\t\tmultiline |\n\t\t\tcode |\n*/\n\n(function(Prism) {\n\n\tPrism.languages.haml = {\n\t\t// Multiline stuff should appear before the rest\n\n\t\t'multiline-comment': [\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)([\\t ]*))\\/.*(\\n\\2[\\t ]+.+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'comment'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)([\\t ]*))-#.*(\\n\\2[\\t ]+.+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'comment'\n\t\t\t}\n\t\t],\n\n\t\t'multiline-code': [\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)([\\t ]*)(?:[~-]|[&!]?=)).*,[\\t ]*(\\n\\2[\\t ]+.*,[\\t ]*)*(\\n\\2[\\t ]+.+)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\trest: Prism.languages.ruby\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)([\\t ]*)(?:[~-]|[&!]?=)).*\\|[\\t ]*(\\n\\2[\\t ]+.*\\|[\\t ]*)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\trest: Prism.languages.ruby\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\n\t\t// See at the end of the file for known filters\n\t\t'filter': {\n\t\t\tpattern: /((?:^|\\n)([\\t ]*)):[\\w-]+(\\n(?:\\2[\\t ]+.+|\\s*?(?=\\n)))+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'filter-name': {\n\t\t\t\t\tpattern: /^:[\\w-]+/,\n\t\t\t\t\talias: 'variable'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t'markup': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)<.+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\trest: Prism.languages.markup\n\t\t\t}\n\t\t},\n\t\t'doctype': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)!!!(?: .+)?/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'tag': {\n\t\t\t// Allows for one nested group of braces\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)[%.#][\\w\\-#.]*[\\w\\-](?:\\([^)]+\\)|\\{(?:\\{[^}]+\\}|[^}])+\\}|\\[[^\\]]+\\])*[\\/<>]*/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attributes': [\n\t\t\t\t\t{\n\t\t\t\t\t\t// Lookbehind tries to prevent interpolations for breaking it all\n\t\t\t\t\t\t// Allows for one nested group of braces\n\t\t\t\t\t\tpattern: /(^|[^#])\\{(?:\\{[^}]+\\}|[^}])+\\}/,\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\trest: Prism.languages.ruby\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /\\([^)]+\\)/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'attr-value': {\n\t\t\t\t\t\t\t\tpattern: /(=\\s*)(?:\"(?:\\\\?.)*?\"|[^)\\s]+)/,\n\t\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'attr-name': /[\\w:-]+(?=\\s*!?=|\\s*[,)])/,\n\t\t\t\t\t\t\t'punctuation': /[=(),]/\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /\\[[^\\]]+\\]/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\trest: Prism.languages.ruby\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'punctuation': /[<>]/\n\t\t\t}\n\t\t},\n\t\t'code': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*(?:[~-]|[&!]?=)).+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\trest: Prism.languages.ruby\n\t\t\t}\n\t\t},\n\t\t// Interpolations in plain text\n\t\t'interpolation': {\n\t\t\tpattern: /#\\{[^}]+\\}/,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.ruby\n\t\t\t}\n\t\t},\n\t\t'punctuation': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)[~=\\-&!]/,\n\t\t\tlookbehind: true\n\t\t}\n\t};\n\n\tvar filter_pattern = '((?:^|\\\\n)([\\\\t ]*)):{{filter_name}}(\\\\n(?:\\\\2[\\\\t ]+.+|\\\\s*?(?=\\\\n)))+';\n\n\t// Non exhaustive list of available filters and associated languages\n\tvar filters = [\n\t\t'css',\n\t\t{filter:'coffee',language:'coffeescript'},\n\t\t'erb',\n\t\t'javascript',\n\t\t'less',\n\t\t'markdown',\n\t\t'ruby',\n\t\t'scss',\n\t\t'textile'\n\t];\n\tvar all_filters = {};\n\tfor (var i = 0, l = filters.length; i < l; i++) {\n\t\tvar filter = filters[i];\n\t\tfilter = typeof filter === 'string' ? {filter: filter, language: filter} : filter;\n\t\tif (Prism.languages[filter.language]) {\n\t\t\tall_filters['filter-' + filter.filter] = {\n\t\t\t\tpattern: RegExp(filter_pattern.replace('{{filter_name}}', filter.filter)),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'filter-name': {\n\t\t\t\t\t\tpattern: /^:[\\w-]+/,\n\t\t\t\t\t\talias: 'variable'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages[filter.language]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPrism.languages.insertBefore('haml', 'filter', all_filters);\n\n}(Prism));","(function(Prism) {\n\n\tvar handlebars_pattern = /\\{\\{\\{[\\w\\W]+?\\}\\}\\}|\\{\\{[\\w\\W]+?\\}\\}/g;\n\t\n\tPrism.languages.handlebars = Prism.languages.extend('markup', {\n\t\t'handlebars': {\n\t\t\tpattern: handlebars_pattern,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^\\{\\{\\{?|\\}\\}\\}?$/i,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'string': /([\"'])(\\\\?.)+?\\1/,\n\t\t\t\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t\t\t\t'boolean': /\\b(true|false)\\b/,\n\t\t\t\t'block': {\n\t\t\t\t\tpattern: /^(\\s*~?\\s*)[#\\/]\\w+/i,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'keyword'\n\t\t\t\t},\n\t\t\t\t'brackets': {\n\t\t\t\t\tpattern: /\\[[^\\]]+\\]/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\tpunctuation: /\\[|\\]/,\n\t\t\t\t\t\tvariable: /[\\w\\W]+/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'punctuation': /[!\"#%&'()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/,\n\t\t\t\t'variable': /[^!\"#%&'()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]+/\n\t\t\t}\n\t\t}\n\t});\n\n\t// Comments are inserted at top so that they can\n\t// surround markup\n\tPrism.languages.insertBefore('handlebars', 'tag', {\n\t\t'handlebars-comment': {\n\t\t\tpattern: /\\{\\{![\\w\\W]*?\\}\\}/,\n\t\t\talias: ['handlebars','comment']\n\t\t}\n\t});\n\n\t// Tokenize all inline Handlebars expressions that are wrapped in {{ }} or {{{ }}}\n\t// This allows for easy Handlebars + markup highlighting\n\tPrism.hooks.add('before-highlight', function(env) {\n\t\tif (env.language !== 'handlebars') {\n\t\t\treturn;\n\t\t}\n\n\t\tenv.tokenStack = [];\n\n\t\tenv.backupCode = env.code;\n\t\tenv.code = env.code.replace(handlebars_pattern, function(match) {\n\t\t\tenv.tokenStack.push(match);\n\n\t\t\treturn '___HANDLEBARS' + env.tokenStack.length + '___';\n\t\t});\n\t});\n\n\t// Restore env.code for other plugins (e.g. line-numbers)\n\tPrism.hooks.add('before-insert', function(env) {\n\t\tif (env.language === 'handlebars') {\n\t\t\tenv.code = env.backupCode;\n\t\t\tdelete env.backupCode;\n\t\t}\n\t});\n\n\t// Re-insert the tokens after highlighting\n\t// and highlight them with defined grammar\n\tPrism.hooks.add('after-highlight', function(env) {\n\t\tif (env.language !== 'handlebars') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, t; t = env.tokenStack[i]; i++) {\n\t\t\tenv.highlightedCode = env.highlightedCode.replace('___HANDLEBARS' + (i + 1) + '___', Prism.highlight(t, env.grammar, 'handlebars'));\n\t\t}\n\n\t\tenv.element.innerHTML = env.highlightedCode;\n\t});\n\n}(Prism));\n","Prism.languages.haskell= {\n\t'comment': {\n\t\tpattern: /(^|[^-!#$%*+=\\?&@|~.:<>^\\\\])(--[^-!#$%*+=\\?&@|~.:<>^\\\\].*(\\r?\\n|$)|{-[\\w\\W]*?-})/m,\n\t\tlookbehind: true\n\t},\n\t'char': /'([^\\\\\"]|\\\\([abfnrtv\\\\\"'&]|\\^[A-Z@[\\]\\^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\\d+|o[0-7]+|x[0-9a-fA-F]+))'/,\n\t'string': /\"([^\\\\\"]|\\\\([abfnrtv\\\\\"'&]|\\^[A-Z@[\\]\\^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\\d+|o[0-7]+|x[0-9a-fA-F]+)|\\\\\\s+\\\\)*\"/,\n\t'keyword' : /\\b(case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\\b/,\n\t'import_statement' : {\n\t\t// The imported or hidden names are not included in this import\n\t\t// statement. This is because we want to highlight those exactly like\n\t\t// we do for the names in the program.\n\t\tpattern: /(\\n|^)\\s*(import)\\s+(qualified\\s+)?(([A-Z][_a-zA-Z0-9']*)(\\.[A-Z][_a-zA-Z0-9']*)*)(\\s+(as)\\s+(([A-Z][_a-zA-Z0-9']*)(\\.[A-Z][_a-zA-Z0-9']*)*))?(\\s+hiding\\b)?/m,\n\t\tinside: {\n\t\t\t'keyword': /\\b(import|qualified|as|hiding)\\b/\n\t\t}\n\t},\n\t// These are builtin variables only. Constructors are highlighted later as a constant.\n\t'builtin': /\\b(abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\\b/,\n\t// decimal integers and floating point numbers | octal integers | hexadecimal integers\n\t'number' : /\\b(\\d+(\\.\\d+)?([eE][+-]?\\d+)?|0[Oo][0-7]+|0[Xx][0-9a-fA-F]+)\\b/,\n\t// Most of this is needed because of the meaning of a single '.'.\n\t// If it stands alone freely, it is the function composition.\n\t// It may also be a separator between a module name and an identifier => no\n\t// operator. If it comes together with other special characters it is an\n\t// operator too.\n\t'operator' : /\\s\\.\\s|([-!#$%*+=\\?&@|~:<>^\\\\]*\\.[-!#$%*+=\\?&@|~:<>^\\\\]+)|([-!#$%*+=\\?&@|~:<>^\\\\]+\\.[-!#$%*+=\\?&@|~:<>^\\\\]*)|[-!#$%*+=\\?&@|~:<>^\\\\]+|(`([A-Z][_a-zA-Z0-9']*\\.)*[_a-z][_a-zA-Z0-9']*`)/,\n\t// In Haskell, nearly everything is a variable, do not highlight these.\n\t'hvariable': /\\b([A-Z][_a-zA-Z0-9']*\\.)*[_a-z][_a-zA-Z0-9']*\\b/,\n\t'constant': /\\b([A-Z][_a-zA-Z0-9']*\\.)*[A-Z][_a-zA-Z0-9']*\\b/,\n\t'punctuation' : /[{}[\\];(),.:]/\n};\n","Prism.languages.http = {\n    'request-line': {\n        pattern: /^(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b\\shttps?:\\/\\/\\S+\\sHTTP\\/[0-9.]+/,\n        inside: {\n            // HTTP Verb\n            property: /^\\b(POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b/,\n            // Path or query argument\n            'attr-name': /:\\w+/\n        }\n    },\n    'response-status': {\n        pattern: /^HTTP\\/1.[01] [0-9]+.*/,\n        inside: {\n            // Status, e.g. 200 OK\n            property: /[0-9]+[A-Z\\s-]+$/i\n        }\n    },\n    // HTTP header name\n    keyword: /^[\\w-]+:(?=.+)/m\n};\n\n// Create a mapping of Content-Type headers to language definitions\nvar httpLanguages = {\n    'application/json': Prism.languages.javascript,\n    'application/xml': Prism.languages.markup,\n    'text/xml': Prism.languages.markup,\n    'text/html': Prism.languages.markup\n};\n\n// Insert each content type parser that has its associated language\n// currently loaded.\nfor (var contentType in httpLanguages) {\n    if (httpLanguages[contentType]) {\n        var options = {};\n        options[contentType] = {\n            pattern: new RegExp('(content-type:\\\\s*' + contentType + '[\\\\w\\\\W]*?)\\\\n\\\\n[\\\\w\\\\W]*', 'i'),\n            lookbehind: true,\n            inside: {\n                rest: httpLanguages[contentType]\n            }\n        };\n        Prism.languages.insertBefore('http', 'keyword', options);\n    }\n}\n","Prism.languages.ini= {\r\n\t'comment': /^\\s*;.*$/m,\r\n\t'important': /\\[.*?\\]/m,\r\n\t'constant': /^\\s*[^\\s=]+?(?=[ \\t]*=)/m,\r\n\t'attr-value': {\r\n\t\tpattern: /=.*/m,\r\n\t\tinside: {\r\n\t\t\t'punctuation': /^[=]/\r\n\t\t}\r\n\t}\r\n};","(function(Prism) {\n\tPrism.languages.jade = {\n\n\t\t// Multiline stuff should appear before the rest\n\n\t\t'multiline-comment': {\n\t\t\tpattern: /((?:^|\\n)([\\t ]*))\\/\\/.*(\\n\\2[\\t ]+.+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'comment'\n\t\t},\n\n\t\t// All the tag-related part is in lookbehind\n\t\t// so that it can be highlighted by the \"tag\" pattern\n\t\t'multiline-script': {\n\t\t\tpattern: /((?:^|\\n)([\\t ]*)script\\b.*\\.[\\t ]*)(\\n(?:\\2[\\t ]+.+|\\s*?(?=\\n)))+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\trest: Prism.languages.javascript\n\t\t\t}\n\t\t},\n\n\t\t// See at the end of the file for known filters\n\t\t'filter': {\n\t\t\tpattern: /((?:^|\\n)([\\t ]*)):.+(\\n(?:\\2[\\t ]+.+|\\s*?(?=\\n)))+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'filter-name': {\n\t\t\t\t\tpattern: /^:[\\w-]+/,\n\t\t\t\t\talias: 'variable'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t'multiline-plain-text': {\n\t\t\tpattern: /((?:^|\\n)([\\t ]*)[\\w\\-#.]+\\.[\\t ]*)(\\n(?:\\2[\\t ]+.+|\\s*?(?=\\n)))+/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'markup': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)<.+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\trest: Prism.languages.markup\n\t\t\t}\n\t\t},\n\t\t'comment': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)\\/\\/.+/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'doctype': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)doctype(?: .+)?/,\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t// This handle all conditional and loop keywords\n\t\t'flow-control': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)(?:if|unless|else|case|when|default|each|while)(?: .+)?/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'each': {\n\t\t\t\t\tpattern: /((?:^|\\n)[\\t ]*)each .+? in\\b/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'keyword': /\\b(?:each|in)\\b/,\n\t\t\t\t\t\t'punctuation': /,/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'branch': {\n\t\t\t\t\tpattern: /((?:^|\\n)[\\t ]*)(?:if|unless|else|case|when|default|while)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'keyword'\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.javascript\n\t\t\t}\n\t\t},\n\t\t'keyword': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)(?:block|extends|include|append|prepend)\\b.+/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'mixin': [\n\t\t\t// Declaration\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)[\\t ]*)mixin .+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'keyword': /^mixin/,\n\t\t\t\t\t'function': /\\w+(?=\\s*\\(|\\s*$)/,\n\t\t\t\t\t'punctuation': /[(),.]/\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Usage\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)[\\t ]*)\\+.+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'name': {\n\t\t\t\t\t\tpattern: /^\\+\\w+/,\n\t\t\t\t\t\talias: 'function'\n\t\t\t\t\t},\n\t\t\t\t\t'rest': Prism.languages.javascript\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'script': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*script(?:(?:&[^(]+)?\\([^)]+\\))*) .+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\trest: Prism.languages.javascript\n\t\t\t}\n\t\t},\n\n\t\t'plain-text': {\n\t\t\t\tpattern: /((?:^|\\n)[\\t ]*(?!-)[\\w\\-#.]*[\\w\\-](?:(?:&[^(]+)?\\([^)]+\\))*\\/?[\\t ]+).+/,\n\t\t\t\tlookbehind: true\n\t\t},\n\t\t'tag': {\n\t\t\tpattern: /((?:^|\\n)[\\t ]*)(?!-)[\\w\\-#.]*[\\w\\-](?:(?:&[^(]+)?\\([^)]+\\))*\\/?:?/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attributes': [\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /&[^(]+\\([^)]+\\)/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /\\([^)]+\\)/,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'attr-value': {\n\t\t\t\t\t\t\t\tpattern: /(=\\s*)(?:\\{[^}]*\\}|[^,)\\n]+)/,\n\t\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t'attr-name': /[\\w-]+(?=\\s*!?=|\\s*[,)])/,\n\t\t\t\t\t\t\t'punctuation': /[!=(),]/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'punctuation': /[:]/\n\t\t\t}\n\t\t},\n\t\t'code': [\n\t\t\t{\n\t\t\t\tpattern: /((?:^|\\n)[\\t ]*(?:-|!?=)).+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'punctuation': /[.\\-!=|]/\n\t};\n\n\tvar filter_pattern = '((?:^|\\\\n)([\\\\t ]*)):{{filter_name}}(\\\\n(?:\\\\2[\\\\t ]+.+|\\\\s*?(?=\\\\n)))+';\n\n\t// Non exhaustive list of available filters and associated languages\n\tvar filters = [\n\t\t{filter:'atpl',language:'twig'},\n\t\t{filter:'coffee',language:'coffeescript'},\n\t\t'ejs',\n\t\t'handlebars',\n\t\t'hogan',\n\t\t'less',\n\t\t'livescript',\n\t\t'markdown',\n\t\t'mustache',\n\t\t'plates',\n\t\t{filter:'sass',language:'scss'},\n\t\t'stylus',\n\t\t'swig'\n\n\t];\n\tvar all_filters = {};\n\tfor (var i = 0, l = filters.length; i < l; i++) {\n\t\tvar filter = filters[i];\n\t\tfilter = typeof filter === 'string' ? {filter: filter, language: filter} : filter;\n\t\tif (Prism.languages[filter.language]) {\n\t\t\tall_filters['filter-' + filter.filter] = {\n\t\t\t\tpattern: RegExp(filter_pattern.replace('{{filter_name}}', filter.filter)),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'filter-name': {\n\t\t\t\t\t\tpattern: /^:[\\w-]+/,\n\t\t\t\t\t\talias: 'variable'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages[filter.language]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPrism.languages.insertBefore('jade', 'filter', all_filters);\n\n}(Prism));","Prism.languages.java = Prism.languages.extend('clike', {\n\t'keyword': /\\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\\b/,\n\t'number': /\\b0b[01]+\\b|\\b0x[\\da-f]*\\.?[\\da-fp\\-]+\\b|\\b\\d*\\.?\\d+[e]?[\\d]*[df]\\b|\\b\\d*\\.?\\d+\\b/i,\n\t'operator': {\n\t\tpattern: /(^|[^\\.])(?:\\+=|\\+\\+?|-=|--?|!=?|<{1,2}=?|>{1,3}=?|==?|&=|&&?|\\|=|\\|\\|?|\\?|\\*=?|\\/=?|%=?|\\^=?|:|~)/m,\n\t\tlookbehind: true\n\t}\n});","(function(Prism) {\n\nvar javascript = Prism.util.clone(Prism.languages.javascript);\n\nPrism.languages.jsx = Prism.languages.extend('markup', javascript);\nPrism.languages.jsx.tag.pattern= /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+|(\\{[\\w\\W]*?\\})))?\\s*)*\\/?>/i;\n\nPrism.languages.jsx.tag.inside['attr-value'].pattern = /=[^\\{](?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i;\n\nPrism.languages.insertBefore('inside', 'attr-value',{\n\t'script': {\n\t\tpattern: /=(\\{[\\w\\W]*?\\})/i,\n\t\tinside: {\n\t\t\t'function' : Prism.languages.javascript.function,\n\t\t\t'punctuation': /[={}[\\];(),.:]/,\n\t\t\t'keyword':  Prism.languages.javascript.keyword\n\t\t},\n\t\t'alias': 'language-javascript'\n\t}\n}, Prism.languages.jsx.tag);\n\n}(Prism));\n","Prism.languages.julia= {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*?(\\r?\\n|$)/,\n\t\tlookbehind: true\n\t},\n\t'string': /\"\"\"[\\s\\S]+?\"\"\"|'''[\\s\\S]+?'''|(\"|')(\\\\?.)*?\\1/,\n\t'keyword' : /\\b(abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|let|local|macro|module|print|println|quote|return|try|type|typealias|using|while)\\b/,\n\t'boolean' : /\\b(true|false)\\b/,\n\t'number' : /\\b-?(0[box])?(?:[\\da-f]+\\.?\\d*|\\.\\d+)(?:e[+-]?\\d+)?j?\\b/i,\n\t'operator' : /[-+]{1,2}|=?<|=?>|!|={1,2}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%|\\b(or|and|not)\\b/,\n\t'punctuation' : /[{}[\\];(),.:]/\n};","Prism.languages.latex = {\n\t'comment': /%.*?(\\r?\\n|$)$/m,\n\t'string': /(\\$)(\\\\?.)*?\\1/,\n\t'punctuation': /[{}]/,\n\t'selector': /\\\\[a-z;,:\\.]*/i\n};","/* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */\n\nPrism.languages.less = Prism.languages.extend('css', {\n\t'comment': [\n\t\t/\\/\\*[\\w\\W]*?\\*\\//,\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?(?:\\([^{}]+\\)|[^(){};])*?(?=\\s*\\{)/i,\n\t\tinside: {\n\t\t\t'punctuation': /[:()]/\n\t\t}\n\t},\n\t// selectors and mixins are considered the same\n\t'selector': {\n\t\tpattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\([^{}]*\\)|[^{};@])*?(?=\\s*\\{)/,\n\t\tinside: {\n\t\t\t// mixin parameters\n\t\t\t'variable': /@+[\\w-]+/\n\t\t}\n\t},\n\n\t'property': /(\\b|\\B)(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/i,\n\t'punctuation': /[{}();:,]/,\n\t'operator': /[+\\-*\\/]/\n});\n\n// Invert function and punctuation positions\nPrism.languages.insertBefore('less', 'punctuation', {\n\t'function': Prism.languages.less.function\n});\n\nPrism.languages.insertBefore('less', 'property', {\n\t'variable': [\n\t\t// Variable declaration (the colon must be consumed!)\n\t\t{\n\t\t\tpattern: /@[\\w-]+\\s*:/,\n\t\t\tinside: {\n\t\t\t\t\"punctuation\": /:/\n\t\t\t}\n\t\t},\n\n\t\t// Variable usage\n\t\t/@@?[\\w-]+/\n\t],\n\t'mixin-usage': {\n\t\tpattern: /([{;]\\s*)[.#](?!\\d)[\\w-]+.*?(?=[(;])/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t}\n});\n","Prism.languages.lolcode = {\n\t'comment': [\n\t\t/\\bOBTW\\s+[\\s\\S]*?\\s+TLDR\\b/,\n\t\t/\\bBTW.+/\n\t],\n\t'string': {\n\t\tpattern: /\"(?::.|[^\"])*\"/,\n\t\tinside: {\n\t\t\t'variable': /:\\{[^}]+\\}/,\n\t\t\t'symbol': [\n\t\t\t\t/:\\([a-f\\d]+\\)/i,\n\t\t\t\t/:\\[[^\\]]+\\]/,\n\t\t\t\t/:[)>o\":]/\n\t\t\t]\n\t\t}\n\t},\n\t'number': /(-|\\b)\\d*\\.?\\d+/,\n\t'symbol': {\n\t\tpattern: /(^|\\s)(?:A )?(?:YARN|NUMBR|NUMBAR|TROOF|BUKKIT|NOOB)(?=\\s|,|$)/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'keyword': /A(?=\\s)/\n\t\t}\n\t},\n\t'label': {\n\t\tpattern: /((?:^|\\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'string'\n\t},\n\t'function': {\n\t\tpattern: /((?:^|\\s)(?:I IZ|HOW IZ I|IZ) )[a-zA-Z]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /(^|\\s)(?:O HAI IM|KTHX|HAI|KTHXBYE|I HAS A|ITZ(?: A)?|R|AN|MKAY|SMOOSH|MAEK|IS NOW(?: A)?|VISIBLE|GIMMEH|O RLY\\?|YA RLY|NO WAI|OIC|MEBBE|WTF\\?|OMG|OMGWTF|GTFO|IM IN YR|IM OUTTA YR|FOUND YR|YR|TIL|WILE|UPPIN|NERFIN|I IZ|HOW IZ I|IF U SAY SO|SRS|HAS A|LIEK(?: A)?|IZ)(?=\\s|,|$)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t/'Z(?=\\s|,|$)/\n\t],\n\t'boolean': {\n\t\tpattern: /(^|\\s)(?:WIN|FAIL)(?=\\s|,|$)/,\n\t\tlookbehind: true\n\t},\n\t'variable': {\n\t\tpattern: /(^|\\s)(?:IT)(?=\\s|,|$)/,\n\t\tlookbehind: true\n\t},\n\t'operator': {\n\t\tpattern: /(^|\\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:SUM|DIFF|PRODUKT|QUOSHUNT|MOD|BIGGR|SMALLR|BOTH|EITHER|WON|ALL|ANY) OF)(?=\\s|,|$)/,\n\t\tlookbehind: true\n\t},\n\t'punctuation': /\\.{3}|\\u2026|,|!/\n};","Prism.languages.markdown = Prism.languages.extend('markup', {});\nPrism.languages.insertBefore('markdown', 'prolog', {\n\t'blockquote': {\n\t\t// > ...\n\t\tpattern: /(^|\\n)>(?:[\\t ]*>)*/,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'code': [\n\t\t{\n\t\t\t// Prefixed by 4 spaces or 1 tab\n\t\t\tpattern: /(^|\\n)(?: {4}|\\t).+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\t{\n\t\t\t// `code`\n\t\t\t// ``code``\n\t\t\tpattern: /``.+?``|`[^`\\n]+`/,\n\t\t\talias: 'keyword'\n\t\t}\n\t],\n\t'title': [\n\t\t{\n\t\t\t// title 1\n\t\t\t// =======\n\n\t\t\t// title 2\n\t\t\t// -------\n\t\t\tpattern: /\\w+.*\\n(?:==+|--+)/,\n\t\t\talias: 'important',\n\t\t\tinside: {\n\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t// # title 1\n\t\t\t// ###### title 6\n\t\t\tpattern: /((?:^|\\n)\\s*)#+.+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'important',\n\t\t\tinside: {\n\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t}\n\t\t}\n\t],\n\t'hr': {\n\t\t// ***\n\t\t// ---\n\t\t// * * *\n\t\t// -----------\n\t\tpattern: /((?:^|\\n)\\s*)([*-])([\\t ]*\\2){2,}(?=\\s*(?:\\n|$))/,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'list': {\n\t\t// * item\n\t\t// + item\n\t\t// - item\n\t\t// 1. item\n\t\tpattern: /((?:^|\\n)\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'url-reference': {\n\t\t// [id]: http://example.com \"Optional title\"\n\t\t// [id]: http://example.com 'Optional title'\n\t\t// [id]: http://example.com (Optional title)\n\t\t// [id]: <http://example.com> \"Optional title\"\n\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:[^>]|\\\\>)+>)(?:[\\t ]+(?:\"(?:[^\"]|\\\\\")*\"|'(?:[^']|\\\\')*'|\\((?:[^)]|\\\\\\))*\\)))?/,\n\t\tinside: {\n\t\t\t'variable': {\n\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'string': /(?:\"(?:[^\"]|\\\\\")*\"|'(?:[^']|\\\\')*'|\\((?:[^)]|\\\\\\))*\\))$/,\n\t\t\t'punctuation': /[[\\]\\(\\)<>:]/\n\t\t},\n\t\talias: 'url'\n\t},\n\t'bold': {\n\t\t// **strong**\n\t\t// __strong__\n\n\t\t// Allow only one line break\n\t\tpattern: /(^|[^\\\\])(\\*\\*|__)(?:\\n(?!\\n)|.)+?\\2/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^\\*\\*|^__|\\*\\*\\s*$|__\\s*$/\n\t\t}\n\t},\n\t'italic': {\n\t\t// *em*\n\t\t// _em_\n\n\t\t// Allow only one line break\n\t\tpattern: /(^|[^\\\\])(?:\\*(?:\\n(?!\\n)|.)+?\\*|_(?:\\n(?!\\n)|.)+?_)/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^[*_]|[*_]$/\n\t\t}\n\t},\n\t'url': {\n\t\t// [example](http://example.com \"Optional title\")\n\t\t// [example] [id]\n\t\tpattern: /!?\\[[^\\]]+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:[^\"]|\\\\\")*\")?\\)| ?\\[[^\\]\\n]*\\])/,\n\t\tinside: {\n\t\t\t'variable': {\n\t\t\t\tpattern: /(!?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"(?:[^\"]|\\\\\")*\"(?=\\)$)/\n\t\t\t}\n\t\t}\n\t}\n});\n\nPrism.languages.markdown['bold'].inside['url'] = Prism.util.clone(Prism.languages.markdown['url']);\nPrism.languages.markdown['italic'].inside['url'] = Prism.util.clone(Prism.languages.markdown['url']);\nPrism.languages.markdown['bold'].inside['italic'] = Prism.util.clone(Prism.languages.markdown['italic']);\nPrism.languages.markdown['italic'].inside['bold'] = Prism.util.clone(Prism.languages.markdown['bold']);","Prism.languages.matlab = {\n\t// We put string before comment, because of printf() patterns that contain \"%\"\n\t'string': {\n\t\tpattern: /(^|\\W)'(?:''|[^'\\n])*'/,\n\t\tlookbehind: true\n\t},\n\t'comment': [\n\t\t/%\\{[\\s\\S]*?\\}%/,\n\t\t/%.+/\n\t],\n\t// FIXME We could handle imaginary numbers as a whole\n\t'number': /\\b-?(?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?(?:[ij])?|[ij])\\b/,\n\t'keyword': /\\b(?:break|case|catch|continue|else|elseif|end|for|function|if|inf|NaN|otherwise|parfor|pause|pi|return|switch|try|while)\\b/,\n\t'function': /(?!\\d)\\w+(?=\\s*\\()/,\n\t'operator': /\\.?[*^\\/\\\\']|[+\\-:@]|[<>=~]=?|&&?|\\|\\|?/,\n\t'punctuation': /\\.{3}|[.,;\\[\\](){}!]/\n};","Prism.languages.nasm = {\n    'comment': /;.*$/m,\n    'string': /(\"|'|`)(\\\\?.)*?\\1/m,\n    'label': {\n        pattern: /^\\s*[A-Za-z\\._\\?\\$][\\w\\.\\?\\$@~#]*:/m,\n        alias: 'function'\n    },\n    'keyword': [\n        /\\[?BITS (16|32|64)\\]?/m,\n        /^\\s*section\\s*[a-zA-Z\\.]+:?/im,\n        /(?:extern|global)[^;]*/im,\n        /(?:CPU|FLOAT|DEFAULT).*$/m\n    ],\n    'register': {\n        pattern: /\\b(?:st\\d|[xyz]mm\\d\\d?|[cdt]r\\d|r\\d\\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(bp|sp|si|di)|[cdefgs]s)\\b/i,\n        alias: 'variable'\n    },\n    'number': /(\\b|-|(?=\\$))(0[hx][\\da-f]*\\.?[\\da-f]+(p[+-]?\\d+)?|\\d[\\da-f]+[hx]|\\$\\d[\\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\\d+|\\d*\\.?\\d+(\\.?e[+-]?\\d+)?[dt]?)\\b/i,\n    'operator': /[\\[\\]\\*+\\-\\/%<>=&|\\$!]/m\n};\n","/**\n * Original by Jan T. Sott (http://github.com/idleberg)\n *\n * Includes all commands and plug-ins shipped with NSIS 3.0a2\n */\n Prism.languages.nsis = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|(^|[^:])(#|;).*?(\\r?\\n|$))/,\n\t\tlookbehind: true\n\t},\n\t'string': /(\"|')(\\\\?.)*?\\1/,\n\t'keyword': /\\b(Abort|Add(BrandingImage|Size)|AdvSplash|Allow(RootDirInstall|SkipFiles)|AutoCloseWindow|Banner|BG(Font|Gradient|Image)|BrandingText|BringToFront|Call(\\b|InstDLL)|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|CRCCheck|Create(Directory|Font|ShortCut)|Delete(\\b|INISec|INIStr|RegKey|RegValue)|Detail(Print|sButtonText)|Dialer|Dir(Text|Var|Verify)|EnableWindow|Enum(RegKey|RegValue)|Exch|Exec(\\b|Shell|Wait)|ExpandEnvStrings|File(\\b|BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|WriteUTF16LE|Seek|Write|WriteByte|WriteWord)|Find(Close|First|Next|Window)|FlushINI|Get(CurInstType|CurrentAddress|DlgItem|DLLVersion|DLLVersionLocal|ErrorLevel|FileTime|FileTimeLocal|FullPathName|Function(\\b|Address|End)|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|Install(ButtonText|Colors|Dir|DirRegKey)|InstProgressFlags|Inst(Type|TypeGetText|TypeSetText)|Int(Cmp|CmpU|Fmt|Op)|IsWindow|Lang(DLL|String)|License(BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(Set|Text)|Manifest(DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|Name|Nop|ns(Dialogs|Exec)|NSISdl|OutFile|Page(\\b|Callbacks)|Pop|Push|Quit|Read(EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|RMDir|SearchPath|Section(\\b|End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)|SendMessage|Set(AutoClose|BrandingImage|Compress|Compressor|CompressorDictSize|CtlColors|CurInstType|DatablockOptimize|DateSave|DetailsPrint|DetailsView|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(InstDetails|UninstDetails|Window)|Silent(Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(Cmp|CmpS|Cpy|Len)|SubCaption|System|Unicode|Uninstall(ButtonText|Caption|Icon|SubCaption|Text)|UninstPage|UnRegDLL|UserInfo|Var|VI(AddVersionKey|FileVersion|ProductVersion)|VPatch|WindowIcon|WriteINIStr|WriteRegBin|WriteRegDWORD|WriteRegExpandStr|Write(RegStr|Uninstaller)|XPStyle)\\b/,\n\t'property': /\\b(admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user|ARCHIVE|FILE_(ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(CR|CU|DD|LM|PD|U)|HKEY_(CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY)\\b/,\n\t'variable': /(\\$(\\(|\\{)?[-_\\w]+)(\\)|\\})?/i,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t'operator': /[-+]{1,2}|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%/,\n\t'punctuation': /[{}[\\];(),.:]/,\n\t'important': /!(addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversionsystem|ifdef|ifmacrodef|ifmacrondef|ifndef|if|include|insertmacro|macroend|macro|makensis|packhdr|searchparse|searchreplace|tempfile|undef|verbose|warning)\\b/i\n};\n","Prism.languages.objectivec = Prism.languages.extend('c', {\n\t'keyword': /(\\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|in|self|super)\\b)|((?=[\\w|@])(@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b)/,\n\t'string': /(?:(\"|')([^\\n\\\\\\1]|\\\\.|\\\\\\r*\\n)*?\\1)|(@\"([^\\n\\\\\"]|\\\\.|\\\\\\r*\\n)*?\")/,\n\t'operator': /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\\->|={1,2}|\\^|~|%|&{1,2}|\\|?\\||\\?|\\*|\\/|@/\n});\n","// Based on Free Pascal\n\n/* TODO\n\tSupport inline asm ?\n*/\n\nPrism.languages.pascal = {\n\t'comment': [\n\t\t/\\(\\*[\\s\\S]+?\\*\\)/,\n\t\t/\\{[\\s\\S]+?\\}/,\n\t\t/\\/\\/.*/\n\t],\n\t'string': [\n\t\t/(?:'(?:''|[^'\\n])*'|#[&$%]?[a-f\\d]+)+/i,\n\t\t// Char\n\t\t/\\^[a-z]/i\n\t],\n\t'keyword': [\n\t\t{\n\t\t\t// Turbo Pascal\n\t\t\tpattern: /(^|(?!&)[\\s\\S])\\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\\b/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\t// Free Pascal\n\t\t\tpattern: /(^|(?!&)[\\s\\S])\\b(?:dispose|exit|false|new|true)\\b/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\t// Object Pascal\n\t\t\tpattern: /(^|(?!&)[\\s\\S])\\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\\b/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\t// Modifiers\n\t\t\tpattern: /(^|(?!&)[\\s\\S])\\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\\b/i,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'number': [\n\t\t// Hexadecimal, octal and binary\n\t\t/[+-]?(?:[&%]\\d+|\\$[a-f\\d]+)/i,\n\t\t// Decimal\n\t\t/([+-]|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?/i\n\t],\n\t'operator': [\n\t\t/\\.\\.|\\*\\*|:=|[<>]{2}|[<>+\\-*\\/]=?|[@^=]/i,\n\t\t{\n\t\t\tpattern: /(^|(?!&)[\\s\\S])\\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\\b/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'punctuation': /\\(\\.|\\.\\)|[()\\[\\]:;,.]/\n};","Prism.languages.perl = {\n\t'comment': [\n\t\t{\n\t\t\t// POD\n\t\t\tpattern: /((?:^|\\n)\\s*)=\\w+[\\s\\S]*?=cut.*/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\$])#.*?(\\r?\\n|$)/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t// TODO Could be nice to handle Heredoc too.\n\t'string': [\n\t\t// q/.../\n\t\t/\\b(?:q|qq|qx|qw)\\s*([^a-zA-Z0-9\\s\\{\\(\\[<])(\\\\?.)*?\\s*\\1/,\n\t\n\t\t// q a...a\n\t\t/\\b(?:q|qq|qx|qw)\\s+([a-zA-Z0-9])(\\\\?.)*?\\s*\\1/,\n\t\n\t\t// q(...)\n\t\t/\\b(?:q|qq|qx|qw)\\s*\\(([^()]|\\\\.)*\\s*\\)/,\n\t\n\t\t// q{...}\n\t\t/\\b(?:q|qq|qx|qw)\\s*\\{([^{}]|\\\\.)*\\s*\\}/,\n\t\n\t\t// q[...]\n\t\t/\\b(?:q|qq|qx|qw)\\s*\\[([^[\\]]|\\\\.)*\\s*\\]/,\n\t\n\t\t// q<...>\n\t\t/\\b(?:q|qq|qx|qw)\\s*<([^<>]|\\\\.)*\\s*>/,\n\n\t\t// \"...\", '...', `...`\n\t\t/(\"|'|`)(\\\\?.)*?\\1/\n\t],\n\t'regex': [\n\t\t// m/.../\n\t\t/\\b(?:m|qr)\\s*([^a-zA-Z0-9\\s\\{\\(\\[<])(\\\\?.)*?\\s*\\1[msixpodualgc]*/,\n\t\n\t\t// m a...a\n\t\t/\\b(?:m|qr)\\s+([a-zA-Z0-9])(\\\\?.)*?\\s*\\1[msixpodualgc]*/,\n\t\n\t\t// m(...)\n\t\t/\\b(?:m|qr)\\s*\\(([^()]|\\\\.)*\\s*\\)[msixpodualgc]*/,\n\t\n\t\t// m{...}\n\t\t/\\b(?:m|qr)\\s*\\{([^{}]|\\\\.)*\\s*\\}[msixpodualgc]*/,\n\t\n\t\t// m[...]\n\t\t/\\b(?:m|qr)\\s*\\[([^[\\]]|\\\\.)*\\s*\\][msixpodualgc]*/,\n\t\n\t\t// m<...>\n\t\t/\\b(?:m|qr)\\s*<([^<>]|\\\\.)*\\s*>[msixpodualgc]*/,\n\t\n\t\t// s/.../.../\n\t\t/\\b(?:s|tr|y)\\s*([^a-zA-Z0-9\\s\\{\\(\\[<])(\\\\?.)*?\\s*\\1\\s*((?!\\1).|\\\\.)*\\s*\\1[msixpodualgcer]*/,\n\t\n\t\t// s a...a...a\n\t\t/\\b(?:s|tr|y)\\s+([a-zA-Z0-9])(\\\\?.)*?\\s*\\1\\s*((?!\\1).|\\\\.)*\\s*\\1[msixpodualgcer]*/,\n\t\n\t\t// s(...)(...)\n\t\t/\\b(?:s|tr|y)\\s*\\(([^()]|\\\\.)*\\s*\\)\\s*\\(\\s*([^()]|\\\\.)*\\s*\\)[msixpodualgcer]*/,\n\t\n\t\t// s{...}{...}\n\t\t/\\b(?:s|tr|y)\\s*\\{([^{}]|\\\\.)*\\s*\\}\\s*\\{\\s*([^{}]|\\\\.)*\\s*\\}[msixpodualgcer]*/,\n\t\n\t\t// s[...][...]\n\t\t/\\b(?:s|tr|y)\\s*\\[([^[\\]]|\\\\.)*\\s*\\]\\s*\\[\\s*([^[\\]]|\\\\.)*\\s*\\][msixpodualgcer]*/,\n\t\n\t\t// s<...><...>\n\t\t/\\b(?:s|tr|y)\\s*<([^<>]|\\\\.)*\\s*>\\s*<\\s*([^<>]|\\\\.)*\\s*>[msixpodualgcer]*/,\n\t\n\t\t// /.../\n\t\t/\\/(\\[.+?]|\\\\.|[^\\/\\r\\n])*\\/[msixpodualgc]*(?=\\s*($|[\\r\\n,.;})&|\\-+*=~<>!?^]|(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\\b))/\n\t],\n\n\t// FIXME Not sure about the handling of ::, ', and #\n\t'variable': [\n\t\t// ${^POSTMATCH}\n\t\t/[&*\\$@%]\\{\\^[A-Z]+\\}/,\n\t\t// $^V\n\t\t/[&*\\$@%]\\^[A-Z_]/,\n\t\t// ${...}\n\t\t/[&*\\$@%]#?(?=\\{)/,\n\t\t// $foo\n\t\t/[&*\\$@%]#?((::)*'?(?!\\d)[\\w$]+)+(::)*/i,\n\t\t// $1\n\t\t/[&*\\$@%]\\d+/,\n\t\t// $_, @_, %!\n\t\t/[\\$@%][!\"#\\$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~]/\n\t],\n\t'filehandle': {\n\t\t// <>, <FOO>, _\n\t\tpattern: /<(?!=).*>|\\b_\\b/,\n\t\talias: 'symbol'\n\t},\n\t'vstring': {\n\t\t// v1.2, 1.2.3\n\t\tpattern: /v\\d+(\\.\\d+)*|\\d+(\\.\\d+){2,}/,\n\t\talias: 'string'\n\t},\n\t'function': {\n\t\tpattern: /sub [a-z0-9_]+/i,\n\t\tinside: {\n\t\t\tkeyword: /sub/\n\t\t}\n\t},\n\t'keyword': /\\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|say|state|sub|switch|undef|unless|until|use|when|while)\\b/,\n\t'number': /(\\n|\\b)-?(0x[\\dA-Fa-f](_?[\\dA-Fa-f])*|0b[01](_?[01])*|(\\d(_?\\d)*)?\\.?\\d(_?\\d)*([Ee]-?\\d+)?)\\b/,\n\t'operator': /-[rwxoRWXOezsfdlpSbctugkTBMAC]\\b|[-+*=~\\/|&]{1,2}|<=?|>=?|\\.{1,3}|[!?\\\\^]|\\b(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\\b/,\n\t'punctuation': /[{}[\\];(),:]/\n};\n","Prism.languages.insertBefore('php', 'variable', {\n\t'this': /\\$this/,\n\t'global': /\\$_?(GLOBALS|SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/,\n\t'scope': {\n\t\tpattern: /\\b[\\w\\\\]+::/,\n\t\tinside: {\n\t\t\tkeyword: /(static|self|parent)/,\n\t\t\tpunctuation: /(::|\\\\)/\n\t\t}\n\t}\n});","/**\n * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/\n * Modified by Miles Johnson: http://milesj.me\n *\n * Supports the following:\n * \t\t- Extends clike syntax\n * \t\t- Support for PHP 5.3+ (namespaces, traits, generators, etc)\n * \t\t- Smarter constant and function matching\n *\n * Adds the following new token classes:\n * \t\tconstant, delimiter, variable, function, package\n */\n\nPrism.languages.php = Prism.languages.extend('clike', {\n\t'keyword': /\\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\\b/i,\n\t'constant': /\\b[A-Z0-9_]{2,}\\b/,\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|(^|[^:])(\\/\\/).*?(\\r?\\n|$))/,\n\t\tlookbehind: true\n\t}\n});\n\n// Shell-like comments are matched after strings, because they are less\n// common than strings containing hashes...\nPrism.languages.insertBefore('php', 'class-name', {\n\t'shell-comment': {\n\t\tpattern: /(^|[^\\\\])#.*?(\\r?\\n|$)/,\n\t\tlookbehind: true,\n\t\talias: 'comment'\n\t}\n});\n\nPrism.languages.insertBefore('php', 'keyword', {\n\t'delimiter': /(\\?>|<\\?php|<\\?)/i,\n\t'variable': /(\\$\\w+)\\b/i,\n\t'package': {\n\t\tpattern: /(\\\\|namespace\\s+|use\\s+)[\\w\\\\]+/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /\\\\/\n\t\t}\n\t}\n});\n\n// Must be defined after the function pattern\nPrism.languages.insertBefore('php', 'operator', {\n\t'property': {\n\t\tpattern: /(->)[\\w]+/,\n\t\tlookbehind: true\n\t}\n});\n\n// Add HTML support of the markup language exists\nif (Prism.languages.markup) {\n\n\t// Tokenize all inline PHP blocks that are wrapped in <?php ?>\n\t// This allows for easy PHP + markup highlighting\n\tPrism.hooks.add('before-highlight', function(env) {\n\t\tif (env.language !== 'php') {\n\t\t\treturn;\n\t\t}\n\n\t\tenv.tokenStack = [];\n\n\t\tenv.backupCode = env.code;\n\t\tenv.code = env.code.replace(/(?:<\\?php|<\\?)[\\w\\W]*?(?:\\?>)/ig, function(match) {\n\t\t\tenv.tokenStack.push(match);\n\n\t\t\treturn '{{{PHP' + env.tokenStack.length + '}}}';\n\t\t});\n\t});\n\n\t// Restore env.code for other plugins (e.g. line-numbers)\n\tPrism.hooks.add('before-insert', function(env) {\n\t\tif (env.language === 'php') {\n\t\t\tenv.code = env.backupCode;\n\t\t\tdelete env.backupCode;\n\t\t}\n\t});\n\n\t// Re-insert the tokens after highlighting\n\tPrism.hooks.add('after-highlight', function(env) {\n\t\tif (env.language !== 'php') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, t; t = env.tokenStack[i]; i++) {\n\t\t\tenv.highlightedCode = env.highlightedCode.replace('{{{PHP' + (i + 1) + '}}}', Prism.highlight(t, env.grammar, 'php'));\n\t\t}\n\n\t\tenv.element.innerHTML = env.highlightedCode;\n\t});\n\n\t// Wrap tokens in classes that are missing them\n\tPrism.hooks.add('wrap', function(env) {\n\t\tif (env.language === 'php' && env.type === 'markup') {\n\t\t\tenv.content = env.content.replace(/(\\{\\{\\{PHP[0-9]+\\}\\}\\})/g, \"<span class=\\\"token php\\\">$1</span>\");\n\t\t}\n\t});\n\n\t// Add the rules before all others\n\tPrism.languages.insertBefore('php', 'comment', {\n\t\t'markup': {\n\t\t\tpattern: /<[^?]\\/?(.*?)>/,\n\t\t\tinside: Prism.languages.markup\n\t\t},\n\t\t'php': /\\{\\{\\{PHP[0-9]+\\}\\}\\}/\n\t});\n}\n","Prism.languages.powershell = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^`])<#[\\w\\W]*?#>/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^`])#.*?(\\r?\\n|$)/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /(\"|')(`?[\\w\\W])*?\\1/m,\n\t\tinside: {}\n\t},\n\t// Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices\n\t'namespace': /\\[[a-z][\\w\\W]*?\\]/i,\n\t'boolean': /\\$(true|false)\\b/i,\n\t'variable': /\\$\\w+\\b/i,\n\t// per http://technet.microsoft.com/en-us/library/hh847744.aspx\n\t'keyword': /\\b(Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|In|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\\b/i,\n\t// Cmdlets and aliases. Aliases should come last, otherwise \"write\" gets preferred over \"write-host\" for example\n\t// Get-Command | ?{ $_.ModuleName -match \"Microsoft.PowerShell.(Util|Core|Management)\" }\n\t// Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match \"Microsoft.PowerShell.(Util|Core|Management)\" }\n\t'function': /\\b(Add-(Computer|Content|History|Member|PSSnapin|Type)|Checkpoint-(Computer|Content|EventLog|History|Item|ItemProperty|Variable)|Compare-(Object)|Complete-(Transaction)|Connect-(PSSession)|ConvertFrom-(Csv|Json|StringData)|Convert-(Path)|ConvertTo-(Csv|Html|Json|Xml)|Copy-(Item|ItemProperty)|Debug-(Process)|Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Disconnect-(PSSession)|Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Enter-(PSSession)|Exit-(PSSession)|Export-(Alias|Clixml|Console|Csv|FormatData|ModuleMember|PSSession)|ForEach-(Object)|Format-(Custom|List|Table|Wide)|Get-(Alias|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Culture|Date|Event|EventLog|EventSubscriber|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|WmiObject)|Group-(Object)|Import-(Alias|Clixml|Csv|LocalizedData|Module|PSSession)|Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)|Join-(Path)|Limit-(EventLog)|Measure-(Command)|Measure-(Object)|Move-(Item|ItemProperty)|New-(Alias|Event|EventLog|Item|ItemProperty|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy)|Out-(Default|File|GridView|Host|Null|Printer|String)|Pop-(Location)|Push-(Location)|Read-(Host)|Receive-(Job)|Receive-(PSSession)|Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)|Remove-(Computer|Event|EventLog|Item|ItemProperty|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)|Rename-(Computer|Item|ItemProperty)|Reset-(ComputerMachinePassword)|Resolve-(Path)|Restart-(Computer|Service)|Restore-(Computer)|Resume-(Job|Service)|Save-(Help)|Select-(Object|String|Xml)|Send-(MailMessage)|Set-(Alias|Content|Date|Item|ItemProperty|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)|Show-(Command|ControlPanelItem|EventLog)|Sort-(Object)|Split-(Path)|Start-(Job|Process|Service|Sleep|Transaction)|Stop-(Computer|Job|Process|Service)|Suspend-(Job|Service)|Tee-(Object)|Test-(ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)|Trace-(Command)|Unblock-(File)|Undo-(Transaction)|Unregister-(Event|PSSessionConfiguration)|Update-(FormatData)|Update-(Help|List|TypeData)|Use-(Transaction)|Wait-(Event|Job|Process)|Where-(Object)|Write-(Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning)|ac|cat|cd|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\\b/i,\n\t'operator': {\n\t\tpattern: /(\\W)-(and|x?or|not|eq|ne|gt|ge|lt|le|Like|(Not)?(Like|Match|Contains|In)|Replace)\\b/i,\n\t\tlookbehind: true\n\t},\n\t'punctuation': /[|{}[\\];(),.]/\n};\n// Variable interpolation inside strings\nPrism.languages.powershell.string.inside.boolean = Prism.languages.powershell.boolean;\nPrism.languages.powershell.string.inside.variable = Prism.languages.powershell.variable;","Prism.languages.python= { \n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*?(\\r?\\n|$)/,\n\t\tlookbehind: true\n\t},\n\t'string': /\"\"\"[\\s\\S]+?\"\"\"|'''[\\s\\S]+?'''|(\"|')(\\\\?.)*?\\1/,\n\t'keyword' : /\\b(as|assert|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\\b/,\n\t'boolean' : /\\b(True|False)\\b/,\n\t'number' : /\\b-?(0[box])?(?:[\\da-f]+\\.?\\d*|\\.\\d+)(?:e[+-]?\\d+)?j?\\b/i,\n\t'operator' : /[-+]|<=?|>=?|!|={1,2}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%|\\b(or|and|not)\\b/,\n\t'punctuation' : /[{}[\\];(),.:]/\n};\n\n","Prism.languages.r = {\n\t'comment': /#.+/,\n\t'string': /(['\"])(?:\\\\?.)*?\\1/,\n\t'percent-operator': {\n\t\t// Includes user-defined operators\n\t\t// and %%, %*%, %/%, %in%, %o%, %x%\n\t\tpattern: /%[^%]*?%/,\n\t\talias: 'operator'\n\t},\n\t'boolean': /\\b(?:TRUE|FALSE)\\b/,\n\t'ellipsis': /\\.\\.(?:\\.|\\d+)/,\n\t'number': [\n\t\t/\\b(?:NaN|Inf)\\b/,\n\t\t/\\b(?:0x[\\dA-Fa-f]+(?:\\.\\d*)?|\\d*\\.?\\d+)(?:[EePp][+-]??\\d+)?[iL]?\\b/\n\t],\n\t'keyword': /\\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\\b/,\n\t'operator': /->>?|<?<-|[<>!=]=?|::?|&&?|\\|\\|?|[+\\-*\\/^$@~]/,\n\t'punctuation': /[(){}\\[\\],;]/\n};","Prism.languages.rest = {\n\t'table': [\n\t\t{\n\t\t\tpattern: /(\\s*)(?:\\+[=-]+)+\\+(?:\\r?\\n|\\r)(?:\\1(?:[+|].+)+[+|](?:\\r?\\n|\\r))+\\1(?:\\+[=-]+)+\\+/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\||(?:\\+[=-]+)+\\+/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\s*)(?:=+ +)+=+((?:\\r?\\n|\\r)\\1.+)+(?:\\r?\\n|\\r)\\1(?:=+ +)+=+(?=(?:\\r?\\n|\\r){2}|\\s*$)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /[=-]+/\n\t\t\t}\n\t\t}\n\t],\n\n\t// Directive-like patterns\n\n\t'substitution-def': {\n\t\tpattern: /(^\\s*\\.\\. )\\|(?:[^|\\s]|[^|\\s][^|]*[^|\\s])\\| [^:]+::/m,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'substitution': {\n\t\t\t\tpattern: /^\\|(?:[^|\\s]|[^|\\s][^|]*[^|\\s])\\|/,\n\t\t\t\talias: 'attr-value',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^\\||\\|$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'directive': {\n\t\t\t\tpattern: /( )[^:]+::/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'function',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /::$/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t'link-target': [\n\t\t{\n\t\t\tpattern: /(^\\s*\\.\\. )\\[[^\\]]+\\]/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^\\[|\\]$/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(^\\s*\\.\\. )_(?:`[^`]+`|(?:\\\\:|[^:])+):/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^_|:$/\n\t\t\t}\n\t\t}\n\t],\n\t'directive': {\n\t\tpattern: /(^\\s*\\.\\. )[^:]+::/m,\n\t\tlookbehind: true,\n\t\talias: 'function',\n\t\tinside: {\n\t\t\t'punctuation': /::$/\n\t\t}\n\t},\n\t'comment': {\n\t\tpattern: /(^\\s*\\.\\.\\s).*(?:(?:\\r?\\n|\\r).*)*?(?=(?:\\r?\\n|\\r){2}|$)/m,\n\t\tlookbehind: true\n\t},\n\n\t'title': [\n\t\t// Overlined and underlined\n\t\t{\n\t\t\tpattern: /^([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]{2,})(?:\\r?\\n|\\r).+(?:\\r?\\n|\\r)\\1$/m,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+|[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,\n\t\t\t\t'important': /.+/\n\t\t\t}\n\t\t},\n\n\t\t// Underlined only\n\t\t{\n\t\t\tpattern: /(^|(?:\\r?\\n|\\r){2}).+(?:\\r?\\n|\\r)[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]{2,}(?=\\r?\\n|\\r|$)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,\n\t\t\t\t'important': /.+/\n\t\t\t}\n\t\t}\n\t],\n\t'hr': {\n\t\tpattern: /((?:\\r?\\n|\\r){2})[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]{4,}(?=(?:\\r?\\n|\\r){2})/,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'list-bullet': {\n\t\tpattern: /(^\\s*)(?:[*+\\-•‣⁃]|\\(?(?:\\d+|[a-z]|[ivxdclm]+)\\)|(?:\\d+|[a-z]|[ivxdclm]+)\\.)(?= )/im,\n\t\tlookbehind: true,\n\t\talias: 'punctuation'\n\t},\n\t'field': {\n\t\tpattern: /(^\\s*):[^:]+:(?= )/m,\n\t\tlookbehind: true,\n\t\talias: 'attr-name'\n\t},\n\t'command-line-option': {\n\t\tpattern: /(^\\s*)(?:[+-][a-z\\d]|(?:\\-\\-|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][a-z\\d_-]*|<[^<>]+>))?(?:, (?:[+-][a-z\\d]|(?:\\-\\-|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][a-z\\d_-]*|<[^<>]+>))?)*(?=(?:\\r?\\n|\\r)? {2,}[\\S])/im,\n\t\tlookbehind: true,\n\t\talias: 'symbol'\n\t},\n\t'literal-block': {\n\t\tpattern: /::(?:\\r?\\n|\\r){2}([ \\t]+).+(?:(?:\\r?\\n|\\r)\\1.+)*/,\n\t\tinside: {\n\t\t\t'literal-block-punctuation': {\n\t\t\t\tpattern: /^::/,\n\t\t\t\talias: 'punctuation'\n\t\t\t}\n\t\t}\n\t},\n\t'quoted-literal-block': {\n\t\tpattern: /::(?:\\r?\\n|\\r){2}([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]).*(?:(?:\\r?\\n|\\r)\\1.*)*/,\n\t\tinside: {\n\t\t\t'literal-block-punctuation': {\n\t\t\t\tpattern: /^(?:::|[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])/m,\n\t\t\t\talias: 'punctuation'\n\t\t\t}\n\t\t}\n\t},\n\t'doctest-block': {\n\t\tpattern: /(^\\s*)>>> .+(?:(?:\\r?\\n|\\r).+)*/m,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^>>>/\n\t\t}\n\t},\n\n\t'inline': [\n\t\t{\n\t\t\tpattern: /(^|[\\s\\-:\\/'\"<(\\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\\*\\*?|``?|\\|)(?!\\s).*?[^\\s]\\2(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$))/m,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'bold': {\n\t\t\t\t\tpattern: /(^\\*\\*).+(?=\\*\\*$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'italic': {\n\t\t\t\t\tpattern: /(^\\*).+(?=\\*$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'inline-literal': {\n\t\t\t\t\tpattern: /(^``).+(?=``$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'symbol'\n\t\t\t\t},\n\t\t\t\t'role': {\n\t\t\t\t\tpattern: /^:[^:]+:|:[^:]+:$/,\n\t\t\t\t\talias: 'function',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /^:|:$/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'interpreted-text': {\n\t\t\t\t\tpattern: /(^`).+(?=`$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'attr-value'\n\t\t\t\t},\n\t\t\t\t'substitution': {\n\t\t\t\t\tpattern: /(^\\|).+(?=\\|$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'attr-value'\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\*\\*?|``?|\\|/\n\t\t\t}\n\t\t}\n\t],\n\n\t'link': [\n\t\t{\n\t\t\tpattern: /\\[[^\\]]+\\]_(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^\\[|\\]_$/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(?:\\b[a-z\\d](?:[_.:+]?[a-z\\d]+)?_?_|`[^`]+`_?_|_`[^`]+`)(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/i,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^_?`|`?_?_$/\n\t\t\t}\n\t\t}\n\t],\n\n\t// Line block start,\n\t// quote attribution,\n\t// explicit markup start,\n\t// and anonymous hyperlink target shortcut (__)\n\t'punctuation': {\n\t\tpattern: /(^\\s*)(?:\\|(?= |$)|(?:---?|—|\\.\\.|__)(?= )|\\.\\.$)/m,\n\t\tlookbehind: true\n\t}\n};","Prism.languages.rip = {\n\t'comment': /#[^\\r\\n]*(\\r?\\n|$)/,\n\n\t'keyword': /(?:=>|->)|\\b(?:class|if|else|switch|case|return|exit|try|catch|finally|raise)\\b/,\n\n\t'builtin': /\\b(@|System)\\b/,\n\n\t'boolean': /\\b(true|false)\\b/,\n\n\t'date': /\\b\\d{4}-\\d{2}-\\d{2}\\b/,\n\t'time': /\\b\\d{2}:\\d{2}:\\d{2}\\b/,\n\t'datetime': /\\b\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\b/,\n\n\t'number': /[+-]?(?:(?:\\d+\\.\\d+)|(?:\\d+))/,\n\n\t'character': /\\B`[^\\s`'\",.:;#\\/\\\\()<>\\[\\]{}]\\b/,\n\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true\n\t},\n\n\t'symbol': /:[^\\d\\s`'\",.:;#\\/\\\\()<>\\[\\]{}][^\\s`'\",.:;#\\/\\\\()<>\\[\\]{}]*/,\n\t'string': /(\"|')(\\\\?.)*?\\1/,\n\n\t'punctuation': /(?:\\.{2,3})|[`,.:;=\\/\\\\()<>\\[\\]{}]/,\n\n\t'reference': /[^\\d\\s`'\",.:;#\\/\\\\()<>\\[\\]{}][^\\s`'\",.:;#\\/\\\\()<>\\[\\]{}]*/\n};\n","/**\n * Original by Samuel Flores\n *\n * Adds the following new token classes:\n * \t\tconstant, builtin, variable, symbol, regex\n */\nPrism.languages.ruby = Prism.languages.extend('clike', {\n\t'comment': /#[^\\r\\n]*(\\r?\\n|$)/,\n\t'keyword': /\\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\\b/,\n\t'builtin': /\\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\\b/,\n\t'constant': /\\b[A-Z][a-zA-Z_0-9]*[?!]?\\b/\n});\n\nPrism.languages.insertBefore('ruby', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true\n\t},\n\t'variable': /[@$]+\\b[a-zA-Z_][a-zA-Z_0-9]*[?!]?\\b/,\n\t'symbol': /:\\b[a-zA-Z_][a-zA-Z_0-9]*[?!]?\\b/\n});\n","/* TODO\n\tAdd support for Markdown notation inside doc comments\n\tAdd support for nested block comments...\n\tMatch closure params even when not followed by dash or brace\n\tAdd better support for macro definition\n*/\n\nPrism.languages.rust = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*?(\\r?\\n|$)/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': [\n\t\t/b?r(#*)\"(?:\\\\?.)*?\"\\1/,\n\t\t/b?(\"|')(?:\\\\?.)*?\\1/\n\t],\n\t'keyword': /\\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n\n\t'attribute': {\n\t\tpattern: /#!?\\[.+?\\]/,\n\t\talias: 'attr-name'\n\t},\n\n\t'function': [\n\t\t/[a-z0-9_]+(?=\\s*\\()/i,\n\t\t// Macros can use parens or brackets\n\t\t/[a-z0-9_]+!(?=\\s*\\(|\\[)/i\n\t],\n\t'macro-rules': {\n\t\tpattern: /[a-z0-9_]+!/i,\n\t\talias: 'function'\n\t},\n\n\t// Hex, oct, bin, dec numbers with visual separators and type suffix\n\t'number': /\\b-?(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\\d(_?\\d)*)?\\.?\\d(_?\\d)*([Ee][+-]?\\d+)?)(?:_?(?:[iu](?:8|16|32)?|f32|f64))?\\b/,\n\n\t// Closure params should not be confused with bitwise OR |\n\t'closure-params': {\n\t\tpattern: /\\|[^|]*\\|(?=\\s*[{-])/,\n\t\tinside: {\n\t\t\t'punctuation': /[\\|:,]/,\n\t\t\t'operator': /[&*]/\n\t\t}\n\t},\n\t'punctuation': /[{}[\\];(),.:]|->/,\n\t'operator': /[-+]{1,2}|!=?|<=?|>=?|={1,3}|&&?|\\|\\|?|\\*|\\/|\\^|%|<<|>>@/\n};","Prism.languages.sas = {\n\t'datalines': {\n\t\tpattern: /(^|[\\r\\n])\\s*(?:(?:data)?lines|cards);[\\s\\S]+?[\\r\\n];/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'keyword': {\n\t\t\t\tpattern: /^(\\s*)(?:(?:data)?lines|cards)/i,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'punctuation': /;/,\n\t\t\t'data': {\n\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\talias: 'string'\n\t\t\t}\n\t\t}\n\t},\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^\\s*|;\\s*)\\*.*;/m,\n\t\t\tlookbehind: true\n\t\t},\n\t\t/\\/\\*[\\s\\S]+?\\*\\//\n\t],\n\t'datetime': {\n\t\t// '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt\n\t\tpattern: /'[^']+'(?:d|d?t)\\b/i,\n\t\talias: 'number'\n\t},\n\t'string': /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n\t'keyword': /\\b(?:data|else|format|if|input|proc|run|then)\\b/i,\n\t// Decimal (1.2e23), hexadecimal (0c1x)\n\t'number': /(?:\\B-|\\b)(?:[\\da-f]+x|\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?)/i,\n\t'operator': /\\*\\*|\\|\\||!!|¦¦|<>|><|[~¬^<>]?=|[*\\/+\\-<>&\\|!¦~¬^]|\\b(?:eq|ne|gt|lt|ge|le|in|not)\\b/i,\n\t'punctuation': /[$%@.(){}\\[\\];,\\\\]/\n};","Prism.languages.scala = Prism.languages.extend('java', {\n\t'keyword': /(<-|=>)|\\b(abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\\b/,\n\t'builtin': /\\b(String|Int|Long|Short|Byte|Boolean|Double|Float|Char|Any|AnyRef|AnyVal|Unit|Nothing)\\b/,\n\t'number': /\\b0x[\\da-f]*\\.?[\\da-f\\-]+\\b|\\b\\d*\\.?\\d+[e]?[\\d]*[dfl]?\\b/i,\n\t'symbol': /'([^\\d\\s]\\w*)/,\n\t'string': /(\"\"\")[\\W\\w]*?\\1|(\"|\\/)[\\W\\w]*?\\2|('.')/\n});\ndelete Prism.languages.scala['class-name'];\ndelete Prism.languages.scala['function'];\n","Prism.languages.scheme = {\n    'boolean' : /#(t|f){1}/,\n    'comment' : /;.*/,\n    'keyword' : {\n\t\tpattern : /([(])(define(-syntax|-library|-values)?|(case-)?lambda|let(-values|(rec)?(\\*)?)?|else|if|cond|begin|delay|delay-force|parameterize|guard|set!|(quasi-)?quote|syntax-rules)/,\n\t\tlookbehind : true\n    },\n    'builtin' : {\n\t\tpattern :  /([(])(cons|car|cdr|null\\?|pair\\?|boolean\\?|eof-object\\?|char\\?|procedure\\?|number\\?|port\\?|string\\?|vector\\?|symbol\\?|bytevector\\?|list|call-with-current-continuation|call\\/cc|append|abs|apply|eval)\\b/,\n\t\tlookbehind : true\n    },\n    'string' :  /([\"])(?:(?=(\\\\?))\\2.)*?\\1|'[^('|\\s)]+/, //thanks http://stackoverflow.com/questions/171480/regex-grabbing-values-between-quotation-marks\n    'number' : /(\\s|\\))[-+]?[0-9]*\\.?[0-9]+((\\s*)[-+]{1}(\\s*)[0-9]*\\.?[0-9]+i)?/,\n    'operator': /(\\*|\\+|\\-|%|\\/|<=|=>|>=|<|=|>)/,\n    'function' : {\n\t\tpattern : /([(])[^(\\s|\\))]*\\s/,\n\t\tlookbehind : true\n    },\n    'punctuation' : /[()]/\n};\n\n    \n\n    \n","Prism.languages.scss = Prism.languages.extend('css', {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*?(\\r?\\n|$))/,\n\t\tlookbehind: true\n\t},\n\t// aturle is just the @***, not the entire rule (to highlight var & stuffs)\n\t// + add ability to highlight number & unit for media queries\n\t'atrule': /@[\\w-]+(?=\\s+(\\(|\\{|;))/i,\n\t// url, compassified\n\t'url': /([-a-z]+-)*url(?=\\()/i,\n\t// CSS selector regex is not appropriate for Sass\n\t// since there can be lot more things (var, @ directive, nesting..)\n\t// a selector must start at the end of a property or after a brace (end of other rules or nesting)\n\t// it can contain some caracters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n\t// the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n\t// can \"pass\" as a selector- e.g: proper#{$erty})\n\t// this one was ard to do, so please be careful if you edit this one :)\n\t'selector': /([^@;\\{\\}\\(\\)]?([^@;\\{\\}\\(\\)]|&|#\\{\\$[-_\\w]+\\})+)(?=\\s*\\{(\\}|\\s|[^\\}]+(:|\\{)[^\\}]+))/m\n});\n\nPrism.languages.insertBefore('scss', 'atrule', {\n\t'keyword': /@(if|else if|else|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)|(?=@for\\s+\\$[-_\\w]+\\s)+from/i\n});\n\nPrism.languages.insertBefore('scss', 'property', {\n\t// var and interpolated vars\n\t'variable': /((\\$[-_\\w]+)|(#\\{\\$[-_\\w]+\\}))/i\n});\n\nPrism.languages.insertBefore('scss', 'function', {\n\t'placeholder': /%[-_\\w]+/i,\n\t'statement': /\\B!(default|optional)\\b/i,\n\t'boolean': /\\b(true|false)\\b/,\n\t'null': /\\b(null)\\b/,\n\t'operator': /\\s+([-+]{1,2}|={1,2}|!=|\\|?\\||\\?|\\*|\\/|%)\\s+/\n});\n","Prism.languages.smalltalk = {\n\t'comment': /\"(?:\"\"|[^\"])+\"/,\n\t'string': /'(?:''|[^'])+'/,\n\t'symbol': /#[\\da-z]+|#(?:-|([+\\/\\\\*~<>=@%|&?!])\\1?)|#(?=\\()/i,\n\t'block-arguments': {\n\t\tpattern: /(\\[\\s*)(?=:)[^\\[|]+?\\|/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'variable': /:[\\da-z]+/i,\n\t\t\t'punctuation': /\\|/\n\t\t}\n\t},\n\t'temporary-variables': {\n\t\tpattern: /\\|[^|]+\\|/,\n\t\tinside: {\n\t\t\t'variable': /[\\da-z]+/i,\n\t\t\t'punctuation': /\\|/\n\t\t}\n\t},\n\t'keyword': /\\b(?:nil|true|false|self|super|new)\\b/,\n\t'character': {\n\t\tpattern: /\\$./,\n\t\talias: 'string'\n\t},\n\t'number': [\n\t\t/\\d+r-?[\\dA-Z]+(?:\\.[\\dA-Z]+)?(?:e-?\\d+)?/,\n\t\t/(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e-?\\d+)?/\n\t],\n\t'operator': /[:=~<>]=|~~|\\/\\/|\\\\\\\\|>>|[!^=<>+\\-*\\/&|,@]/,\n\t'punctuation': /[.;:?\\[\\](){}]/\n};","/* TODO\n\tAdd support for variables inside double quoted strings\n\tAdd support for {php}\n*/\n\n(function(Prism) {\n\n\tvar smarty_pattern = /\\{\\*[\\w\\W]+?\\*\\}|\\{[\\w\\W]+?\\}/g;\n\tvar smarty_litteral_start = '{literal}';\n\tvar smarty_litteral_end = '{/literal}';\n\tvar smarty_litteral_mode = false;\n\t\n\tPrism.languages.smarty = Prism.languages.extend('markup', {\n\t\t'smarty': {\n\t\t\tpattern: smarty_pattern,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^\\{|\\}$/i,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'string': /([\"'])(\\\\?.)*?\\1/,\n\t\t\t\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t\t\t\t'variable': [\n\t\t\t\t\t/\\$(?!\\d)\\w+/,\n\t\t\t\t\t/#(?!\\d)\\w+#/,\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /(\\.|->)(?!\\d)\\w+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /(\\[)(?!\\d)\\w+(?=\\])/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'function': [\n\t\t\t\t\t{\n\t\t\t\t\t\tpattern: /(\\|\\s*)@?(?!\\d)\\w+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t/^\\/?(?!\\d)\\w+/,\n\t\t\t\t\t/(?!\\d)\\w+(?=\\()/\n\t\t\t\t],\n\t\t\t\t'attr-name': {\n\t\t\t\t\t// Value is made optional because it may have already been tokenized\n\t\t\t\t\tpattern: /\\w+\\s*=\\s*(?:(?!\\d)\\w+)?/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t\"variable\": {\n\t\t\t\t\t\t\tpattern: /(=\\s*)(?!\\d)\\w+/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"punctuation\": /=/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'punctuation': /[\\[\\]().,=\\|:`]|\\->/,\n\t\t\t\t'operator': [\n\t\t\t\t\t/[+\\-*\\/%]|===?|[!<>]=?|&&|\\|\\|/,\n\t\t\t\t\t/\\bis\\s+(?:not\\s+)?(?:div|even|odd)(?:\\s+by)?\\b/,\n\t\t\t\t\t/\\b(?:eq|neq?|gt|lt|gt?e|lt?e|not|mod|or|and)\\b/\n\t\t\t\t],\n\t\t\t\t'keyword': /\\b(?:false|off|on|no|true|yes)\\b/\n\t\t\t}\n\t\t}\n\t});\n\n\t// Comments are inserted at top so that they can\n\t// surround markup\n\tPrism.languages.insertBefore('smarty', 'tag', {\n\t\t'smarty-comment': {\n\t\t\tpattern: /\\{\\*[\\w\\W]*?\\*\\}/,\n\t\t\talias: ['smarty','comment']\n\t\t}\n\t});\n\n\t// Tokenize all inline Smarty expressions\n\tPrism.hooks.add('before-highlight', function(env) {\n\t\tif (env.language !== 'smarty') {\n\t\t\treturn;\n\t\t}\n\n\t\tenv.tokenStack = [];\n\n\t\tenv.backupCode = env.code;\n\t\tenv.code = env.code.replace(smarty_pattern, function(match) {\n\n\t\t\t// Smarty tags inside {literal} block are ignored\n\t\t\tif(match === smarty_litteral_end) {\n\t\t\t\tsmarty_litteral_mode = false;\n\t\t\t}\n\n\t\t\tif(!smarty_litteral_mode) {\n\t\t\t\tif(match === smarty_litteral_start) {\n\t\t\t\t\tsmarty_litteral_mode = true;\n\t\t\t\t}\n\t\t\t\tenv.tokenStack.push(match);\n\n\t\t\t\treturn '___SMARTY' + env.tokenStack.length + '___';\n\t\t\t}\n\t\t\treturn match;\n\t\t});\n\t});\n\n\t// Restore env.code for other plugins (e.g. line-numbers)\n\tPrism.hooks.add('before-insert', function(env) {\n\t\tif (env.language === 'smarty') {\n\t\t\tenv.code = env.backupCode;\n\t\t\tdelete env.backupCode;\n\t\t}\n\t});\n\n\t// Re-insert the tokens after highlighting\n\t// and highlight them with defined grammar\n\tPrism.hooks.add('after-highlight', function(env) {\n\t\tif (env.language !== 'smarty') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, t; t = env.tokenStack[i]; i++) {\n\t\t\tenv.highlightedCode = env.highlightedCode.replace('___SMARTY' + (i + 1) + '___', Prism.highlight(t, env.grammar, 'smarty'));\n\t\t}\n\n\t\tenv.element.innerHTML = env.highlightedCode;\n\t});\n\n}(Prism));","Prism.languages.sql= { \n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|((--)|(\\/\\/)|#).*?(\\r?\\n|$))/,\n\t\tlookbehind: true\n\t},\n\t'string' : {\n\t\tpattern: /(^|[^@])(\"|')(\\\\?[\\s\\S])*?\\2/,\n\t\tlookbehind: true\n\t},\n\t'variable': /@[\\w.$]+|@(\"|'|`)(\\\\?[\\s\\S])+?\\1/,\n\t'function': /\\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALTER|ANALYZE|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADE|CASCADED|CASE|CHAIN|CHAR VARYING|CHARACTER VARYING|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATA|DATABASE|DATABASES|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DOUBLE PRECISION|DROP|DUMMY|DUMP|DUMPFILE|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE|ESCAPED BY|EXCEPT|EXEC|EXECUTE|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR|FOR EACH ROW|FORCE|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GEOMETRY|GEOMETRYCOLLECTION|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEY|KEYS|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONGBLOB|LONGTEXT|MATCH|MATCHED|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTILINESTRING|MULTIPOINT|MULTIPOLYGON|NATIONAL|NATIONAL CHAR VARYING|NATIONAL CHARACTER|NATIONAL CHARACTER VARYING|NATIONAL VARCHAR|NATURAL|NCHAR|NCHAR VARCHAR|NEXT|NO|NO SQL|NOCHECK|NOCYCLE|NONCLUSTERED|NULLIF|NUMERIC|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPTIMIZE|OPTION|OPTIONALLY|ORDER|OUT|OUTER|OUTFILE|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC|PROCEDURE|PUBLIC|PURGE|QUICK|RAISERROR|READ|READS SQL DATA|READTEXT|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURN|RETURNS|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROWCOUNT|ROWGUIDCOL|ROWS?|RTREE|RULE|SAVE|SAVEPOINT|SCHEMA|SELECT|SERIAL|SERIALIZABLE|SESSION|SESSION_USER|SET|SETUSER|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START|STARTING BY|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLE|TABLES|TABLESPACE|TEMP(?:ORARY)?|TEMPTABLE|TERMINATED BY|TEXT|TEXTSIZE|THEN|TIMESTAMP|TINYBLOB|TINYINT|TINYTEXT|TO|TOP|TRAN|TRANSACTION|TRANSACTIONS|TRIGGER|TRUNCATE|TSEQUAL|TYPE|TYPES|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNPIVOT|UPDATE|UPDATETEXT|USAGE|USE|USER|USING|VALUE|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH|WITH ROLLUP|WITHIN|WORK|WRITE|WRITETEXT)\\b/i,\n\t'boolean': /\\b(?:TRUE|FALSE|NULL)\\b/i,\n\t'number': /\\b-?(0x)?\\d*\\.?[\\da-f]+\\b/,\n\t'operator': /\\b(?:ALL|AND|ANY|BETWEEN|EXISTS|IN|LIKE|NOT|OR|IS|UNIQUE|CHARACTER SET|COLLATE|DIV|OFFSET|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b|[-+]|!|[=<>]{1,2}|(&){1,2}|\\|?\\||\\?|\\*|\\//i,\n\t'punctuation': /[;[\\]()`,.]/\n};","Prism.languages.stylus = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*?(\\r?\\n|$))/g,\n\t\tlookbehind: true\n\t},\n\t'keyword': /(px|r?em|ex|ch|vw|vh|vmin|vmax|deg|grad|rad|turn|m?s|k?Hz|dpi|dppx|dpcm)\\b|\\b(is|defined|not|isnt|and|or|unless|for|in)\\b/g,\n\t'atrule': /@[\\w-]+(?=\\s+\\S+)/gi,\n\t'url': /url\\(([\"']?).*?\\1\\)/gi,\n\t'variable': /^\\s*([\\w-]+)(?=\\s*[+-\\\\]?=)/gm,\n\t'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/g,\n\t'important': /\\B!important\\b/gi,\n\t'hexcode': /#[\\da-f]{3,6}/gi,\n\t'entity': /\\\\[\\da-f]{1,8}/gi,\n\t'number': /\\d+\\.?\\d*%?/g,\n\t'selector': [\n\t\t{\n\t\t\tpattern: /::?(after|before|first-letter|first-line|selection)/g,\n\t\t\talias: 'pseudo-element'\n\t\t},{\n\t\t\tpattern: /:(?:active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|in-range|invalid|lang|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-of-type|only-child|optional|out-of-range|read-only|read-write|required|root|target|valid|visited)(?:\\(.*\\))?/g,\n\t\t\talias:'pseudo-class'\n\t\t},{\n\t\t\tpattern: /\\[[\\w-]+?\\s*[*~$^|=]?(?:=\\s*\\S+)?\\]/g,\n\t\t\tinside: {\n\t\t\t\t\"attr-name\":\n\t\t\t\t{\n\t\t\t\t\tpattern: /(\\[)([\\w-]+)(?=\\s*[*~$^|=]{0,2})/g,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t\"punctuation\": /\\[|\\]/g,\n\t\t\t\t\"operator\": /[*~$^|=]/g,\n\t\t\t\t\"attr-value\": {\n\t\t\t\t\tpattern: /\\S+/\n\t\t\t\t},\n\t\t\t},\n\t\t\talias: 'attr'\n\t\t},\n\t\t{\n\t\t\tpattern: /\\.[a-z-]+/i,\n\t\t\talias: 'class'\n\t\t},\n\t\t{\n\t\t\tpattern: /#[a-z-]+/i,\n\t\t\talias: 'id'\n\t\t},\n\t\t{\n\t\t\tpattern: /\\b(html|head|title|base|link|meta|style|script|noscript|template|body|section|nav|article|aside|h[1-6]|header|footer|address|main|p|hr|pre|blockquote|ol|ul|li|dl|dt|dd|figure|figcaption|div|a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|dbo|span|br|wbr|ins|del|image|iframe|embed|object|param|video|audio|source|track|canvas|map|area|sv|math|table|caption|colgroup|col|tbody|thead|tfoot|tr|td|th|form|fieldset|legeng|label|input|button|select|datalist|optgroup|option|textarea|keygen|output|progress|meter|details|summary|menuitem|menu)\\b/g,\n\t\t\talias: 'tag'\n\t\t},\n\t],\n\t'property': [\n\t\t/^\\s*([a-z-]+)(?=\\s+[\\w\\W]+|\\s*:)(?!\\s*\\{|\\r?\\n)/mig,\n\t\t{\n\t\t\tpattern: /(\\(\\s*)([a-z-]+)(?=\\s*:)/ig,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'function': /[-a-z0-9]+(?=\\()/ig,\n\t'punctuation': /[\\{\\};:]/g,\n\t'operator': /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%/g\n}\n","// issues: nested multiline comments, highlighting inside string interpolations\nPrism.languages.swift = Prism.languages.extend('clike', {\n\t'keyword': /\\b(as|associativity|break|case|class|continue|convenience|default|deinit|didSet|do|dynamicType|else|enum|extension|fallthrough|final|for|func|get|if|import|in|infix|init|inout|internal|is|lazy|left|let|mutating|new|none|nonmutating|operator|optional|override|postfix|precedence|prefix|private|protocol|public|required|return|right|safe|self|Self|set|static|struct|subscript|super|switch|Type|typealias|unowned|unowned|unsafe|var|weak|where|while|willSet|__COLUMN__|__FILE__|__FUNCTION__|__LINE__)\\b/,\n\t'number': /\\b([\\d_]+(\\.[\\de_]+)?|0x[a-f0-9_]+(\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n\t'constant': /\\b(nil|[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n\t'atrule': /@\\b(IBOutlet|IBDesignable|IBAction|IBInspectable|class_protocol|exported|noreturn|NSCopying|NSManaged|objc|UIApplicationMain|auto_closure)\\b/,\n\t'builtin': /\\b([A-Z]\\S+|abs|advance|alignof|alignofValue|assert|contains|count|countElements|debugPrint|debugPrintln|distance|dropFirst|dropLast|dump|enumerate|equal|filter|find|first|getVaList|indices|isEmpty|join|last|lazy|lexicographicalCompare|map|max|maxElement|min|minElement|numericCast|overlaps|partition|prefix|print|println|reduce|reflect|reverse|sizeof|sizeofValue|sort|sorted|split|startsWith|stride|strideof|strideofValue|suffix|swap|toDebugString|toString|transcode|underestimateCount|unsafeBitCast|withExtendedLifetime|withUnsafeMutablePointer|withUnsafeMutablePointers|withUnsafePointer|withUnsafePointers|withVaList)\\b/\n});\n","Prism.languages.twig = {\n\t'comment': /\\{#[\\s\\S]*?#\\}/,\n\t'tag': {\n\t\tpattern: /(\\{\\{[\\s\\S]*?\\}\\}|\\{%[\\s\\S]*?%\\})/,\n\t\tinside: {\n\t\t\t'ld': {\n\t\t\t\tpattern: /^(\\{\\{\\-?|\\{%\\-?\\s*\\w+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^(\\{\\{|\\{%)\\-?/,\n\t\t\t\t\t'keyword': /\\w+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'rd': {\n\t\t\t\tpattern: /\\-?(%\\}|\\}\\})$/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /.*/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /(\"|')(\\\\?.)*?\\1/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^('|\")|('|\")$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'keyword': /\\b(if)\\b/,\n\t\t\t'boolean': /\\b(true|false|null)\\b/,\n\t\t\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t\t\t'operator': /==|=|!=|<|>|>=|<=|\\+|\\-|~|\\*|\\/|\\/\\/|%|\\*\\*|\\|/,\n\t\t\t'space-operator': {\n\t\t\t\tpattern: /(\\s)(\\b(not|b\\-and|b\\-xor|b\\-or|and|or|in|matches|starts with|ends with|is)\\b|\\?|:|\\?:)(?=\\s)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'operator': /.*/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'property': /\\b[a-zA-Z_][a-zA-Z0-9_]*\\b/,\n\t\t\t'punctuation': /\\(|\\)|\\[\\]|\\[|\\]|\\{|\\}|:|\\.|,/\n\t\t}\n\t},\n\n\t// The rest can be parsed as HTML\n\t'other': {\n\t\tpattern: /[\\s\\S]*/,\n\t\tinside: Prism.languages.markup\n\t}\n};\n","Prism.languages.typescript = Prism.languages.extend('javascript', {\n\t'keyword': /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield|module|declare|constructor|string|Function|any|number|boolean|Array|enum)\\b/\n});\n","Prism.languages.wiki = Prism.languages.extend('markup', {\n\t'block-comment': {\n\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\tlookbehind: true,\n\t\talias: 'comment'\n\t},\n\t'heading': {\n\t\tpattern: /^(=+).+?\\1/m,\n\t\tinside: {\n\t\t\t'punctuation': /^=+|=+$/,\n\t\t\t'important': /.+/\n\t\t}\n\t},\n\t'emphasis': {\n\t\tpattern: /('{2,4}).+?\\1/,\n\t\tinside: {\n\t\t\t'bold italic': {\n\t\t\t\tpattern: /('''').+?(?=\\1)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'bold': {\n\t\t\t\tpattern: /(''').+?(?=\\1)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'italic': {\n\t\t\t\tpattern: /('').+?(?=\\1)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'punctuation': /^''+|''+$/\n\t\t}\n\t},\n\t'hr': {\n\t\tpattern: /^-{4,}/m,\n\t\talias: 'punctuation'\n\t},\n\t'url': [\n\t\t/ISBN +(?:97[89][ -]?)?(?:\\d[ -]?){9}[\\dx]\\b/i,\n\t\t/(?:RFC|PMID) +\\d+/,\n\t\t/\\[\\[.+?\\]\\]/,\n\t\t/\\[.+?\\]/\n\t],\n\t'variable': [\n\t\t/__[A-Z]+__/,\n\t\t/\\{{3}.+?\\}{3}/,\n\t\t/\\{\\{.+?}}/\n\t],\n\t'symbol': [\n\t\t/^#redirect/im,\n\t\t/~{3,5}/\n\t],\n\t// Handle table attrs:\n\t// {|\n\t// ! style=\"text-align:left;\"| Item\n\t// |}\n\t'table-tag': {\n\t\tpattern: /((?:^|[|!])[|!])[^|\\r\\n]+\\|(?!\\|)/m,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'table-bar': {\n\t\t\t\tpattern: /\\|$/,\n\t\t\t\talias: 'punctuation'\n\t\t\t},\n\t\t\trest: Prism.languages.markup['tag'].inside\n\t\t}\n\t},\n\t'punctuation': /^(?:\\{\\||\\|\\}|\\|-|[*#:;!|])|\\|\\||!!/m\n});\n\nPrism.languages.insertBefore('wiki', 'tag', {\n\t// Prevent highlighting inside <nowiki>, <source> and <pre> tags\n\t'nowiki': {\n\t\tpattern: /<(nowiki|pre|source)\\b[\\w\\W]*?>[\\w\\W]*?<\\/\\1>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /<(?:nowiki|pre|source)\\b[\\w\\W]*?>|<\\/(?:nowiki|pre|source)>/i,\n\t\t\t\tinside: Prism.languages.markup['tag'].inside\n\t\t\t}\n\t\t}\n\t}\n});\n","Prism.languages.yaml = {\n\t'scalar': {\n\t\tpattern: /([\\-:]\\s*(![^\\s]+)?[ \\t]*[|>])[ \\t]*(?:(\\n[ \\t]+)[^\\r\\n]+(?:\\3[^\\r\\n]+)*)/,\n\t\tlookbehind: true,\n\t\talias: 'string'\n\t},\n\t'comment': /#[^\\n]+/,\n\t'key': {\n\t\tpattern: /(\\s*[:\\-,[{\\n?][ \\t]*(![^\\s]+)?[ \\t]*)[^\\n{[\\]},#]+?(?=\\s*:\\s)/,\n\t\tlookbehind: true,\n\t\talias: 'atrule'\n\t},\n\t'directive': {\n\t\tpattern: /((^|\\n)[ \\t]*)%[^\\n]+/,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\t'datetime': {\n\t\tpattern: /([:\\-,[{]\\s*(![^\\s]+)?[ \\t]*)(\\d{4}-\\d\\d?-\\d\\d?([tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(\\.\\d*)?[ \\t]*(Z|[-+]\\d\\d?(:\\d{2})?)?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(:\\d{2}(\\.\\d*)?)?)(?=[ \\t]*(\\n|$|,|]|}))/,\n\t\tlookbehind: true,\n\t\talias: 'number'\n\t},\n\t'boolean': {\n\t\tpattern: /([:\\-,[{]\\s*(![^\\s]+)?[ \\t]*)(true|false)[ \\t]*(?=\\n|$|,|]|})/i,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\t'null': {\n\t\tpattern: /([:\\-,[{]\\s*(![^\\s]+)?[ \\t]*)(null|~)[ \\t]*(?=\\n|$|,|]|})/i,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\t'string': {\n\t\tpattern: /([:\\-,[{]\\s*(![^\\s]+)?[ \\t]*)(\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*')(?=[ \\t]*(\\n|$|,|]|}))/,\n\t\tlookbehind: true\n\t},\n\t'number': {\n\t\tpattern: /([:\\-,[{]\\s*(![^\\s]+)?[ \\t]*)[+\\-]?(0x[\\dA-Fa-f]+|0o[0-7]+|(\\d+\\.?\\d*|\\.?\\d+)(e[\\+\\-]?\\d+)?|\\.inf|\\.nan)[ \\t]*(?=\\n|$|,|]|})/i,\n\t\tlookbehind: true\n\t},\n\t'tag': /![^\\s]+/,\n\t'important': /[&*][\\w]+/,\n\t'punctuation': /([:[\\]{}\\-,|>?]|---|\\.\\.\\.)/\n};\n","var cledit = window.cledit($('pre').get(0), $('pre').parent().get(0))\r\nconsole.log($('pre'))\r\n"],"sourceRoot":"/source/"}